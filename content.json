{"posts":[{"title":"JavaScript判断类型的几种方式","text":"JavaScript判断类型的几种方式1、js中的数据类型JavaScript有八种数据类型: Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。 其中Symbol和BigInt是ES6中新增的数据类型： Symbol 可以创建独一无二且不可变的数据类型，主要为了解决全局变量冲突的问题。 BigInt 是一种数字类型的数据，可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。 基本数据类型：Undefined、Null、Boolean、Number、String、Symbol、BigInt。 引用数据类型 ：Object（JS中除了基本类型以外都是对象,数组,函数,正则表达式）。 2、typeof123456789101112131415161718let bool = false, num = 0, str = &quot;hello,world&quot;, u = undefined, n = null, arr = [], obj = {}, func = function(){}, s = Symbol()console.log(typeof bool); //booleanconsole.log(typeof num); //numberconsole.log(typeof str); //stringconsole.log(typeof u); //undefinedconsole.log(typeof n); //objectconsole.log(typeof arr); //objectconsole.log(typeof obj); //objectconsole.log(typeof fun); //functionconsole.log(typeof s); //symbol typeof除了基本类型boolean,number,undefined,string,symbol和function可以正确识别以外 ，Array、Object、null都为对象。 3、constructor1234567console.log(bool.constructor === Boolean);// trueconsole.log(num.constructor === Number);// trueconsole.log(str.constructor === String);// trueconsole.log(arr.constructor === Array);// trueconsole.log(obj.constructor === Object);// trueconsole.log(fun.constructor === Function);// trueconsole.log(s.constructor === Symbol);//true null、undefined没有construstor方法，因此constructor不能判断undefined和null。 但是他是不安全的，因为contructor的指向是可以被改变。 4、instanceof123456789console.log(bool instanceof Boolean); // falseconsole.log(num instanceof Number); // falseconsole.log(str instanceof String); // falseconsole.log(u instanceof Object); // falseconsole.log(n instanceof Object); // falseconsole.log(arr instanceof Array); // trueconsole.log(obj instanceof Object); // trueconsole.log(fun instanceof Function); // trueconsole.log(s instanceof Symbol); // false 从结果中看出instanceof不能识别出基本的数据类型 number、boolean、string、undefined、unll、symbol。 但是可以检测出引用类型，如array、object、function，同时对于是使用new声明的类型，它还可以检测出多层继承关系。 其实也很好理解，js的继承都是采用原型链来继承的。比如objA instanceof A ，其实就是看objA的原型链上是否有A的原型，而A的原型上保留A的constructor属性。 所以instanceof一般用来检测对象类型，以及继承关系。 5、Object.prototype.toString.call123456789console.log(Object.prototype.toString.call(bool));//[object Boolean]console.log(Object.prototype.toString.call(num));//[object Number]console.log(Object.prototype.toString.call(str));//[object String]console.log(Object.prototype.toString.call(u));//[object Undefined]console.log(Object.prototype.toString.call(n));//[object Null]console.log(Object.prototype.toString.call(arr));//[object Array]console.log(Object.prototype.toString.call(obj));//[object Object]console.log(Object.prototype.toString.call(fun));//[object Function]console.log(Object.prototype.toString.call(s)); //[object Symbol] 在项目中常用的就是此方法，使用哪个判断，还是要看使用场景，一般基本的类型可以选择typeof，引用类型可以使用instanceof。 toString、obj.toString()同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？ 这是因为toString是Object的原型方法，而Array、function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。","link":"/note/2022/03/25/JavaScript%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"title":"Vue源码中可借鉴的基础方法","text":"判断值是否为undefined或者null123function isUndef (v) { return v === undefined || v === null} 判断值是否不为undefined或者null123function isDef (v) { return v !== undefined &amp;&amp; v !== null} 判断值是否为true123function isTrue (v) { return v === true} 判断值是否为false123function isFalse (v) { return v === false} 判断值是否为原始值123456789function isPrimitive (value) { return ( typeof value === 'string' || typeof value === 'number' || // $flow-disable-line typeof value === 'symbol' || typeof value === 'boolean' )} 判断一个对象类型123function isObject (obj) { return obj !== null &amp;&amp; typeof obj === 'object'} 通过Object.prototype.toString 判断类型12345var _toString = Object.prototype.toString;function toRawType (value) { return _toString.call(value).slice(8, -1)} 判断一个Promise对象1234567function isPromise (val) { return ( isDef(val) &amp;&amp; typeof val.then === 'function' &amp;&amp; typeof val.catch === 'function' )} 将类数组转换为数组123456789function toArray (list, start) { start = start || 0; var i = list.length - start; var ret = new Array(i); while (i--) { ret[i] = list[i + start]; } return ret} 判断两个对象或者数组是否相同12345678910111213141516171819202122232425262728293031323334function looseEqual (a, b) { if (a === b) { return true } var isObjectA = isObject(a); var isObjectB = isObject(b); if (isObjectA &amp;&amp; isObjectB) { try { var isArrayA = Array.isArray(a); var isArrayB = Array.isArray(b); if (isArrayA &amp;&amp; isArrayB) { return a.length === b.length &amp;&amp; a.every(function (e, i) { return looseEqual(e, b[i]) }) } else if (a instanceof Date &amp;&amp; b instanceof Date) { return a.getTime() === b.getTime() } else if (!isArrayA &amp;&amp; !isArrayB) { var keysA = Object.keys(a); var keysB = Object.keys(b); return keysA.length === keysB.length &amp;&amp; keysA.every(function (key) { return looseEqual(a[key], b[key]) }) } else { /* istanbul ignore next */ return false } } catch (e) { /* istanbul ignore next */ return false } } else if (!isObjectA &amp;&amp; !isObjectB) { return String(a) === String(b) } else { return false }} 简单的绑定会比原生更快12345678910111213function bind (fn, ctx) { function boundFn (a) { var l = arguments.length;//获取实参的数量 return l ? l &gt; 1//如果实参数量大于1 ? fn.apply(ctx, arguments) : fn.call(ctx, a)//实参数量等于1 : fn.call(ctx)//没有参数 } // record original fn length//记录一下原始的形参数量 boundFn._length = fn.length; return boundFn} 将一个通过 -连接的字符串转为驼峰1234567var hyphenateRE = /([^-])([A-Z])/g;var hyphenate = cached(function (str) { return str .replace(hyphenateRE, '$1-$2')//$1为正则表达式匹配的第一个元素$2为第二个元素 .replace(hyphenateRE, '$1-$2') .toLowerCase()//使之最小化});","link":"/note/2022/03/28/Vue%E6%BA%90%E7%A0%81%E4%B8%AD%E5%8F%AF%E5%80%9F%E9%89%B4%E7%9A%84%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95/"},{"title":"ajax、fetch、axios的区别","text":"ajax、axios、fetch的区别（1）AJAX Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下： 本身是针对MVC编程，不符合前端MVVM的浪潮 基于原生XHR开发，XHR本身的架构不清晰 不符合关注分离（Separation of Concerns）的原则 配置和调用方式非常混乱，而且基于事件的异步模型不友好。 （2）Fetch fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。 fetch的优点： 语法简洁，更加语义化 基于标准 Promise 实现，支持 async/await 更加底层，提供的API丰富（request, response） 脱离了XHR，是ES规范里新的实现方式 fetch的缺点： fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。 fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’}) fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费 fetch没有办法原生监测请求的进度，而XHR可以 （3）Axios Axios 是一种基于Promise封装的HTTP客户端，其特点如下： 浏览器端发起XMLHttpRequests请求 node端发起http请求 支持Promise API 监听请求和返回 对请求和返回进行转化 取消请求 自动转换json数据 客户端支持抵御XSRF攻击 原文地址","link":"/note/2022/03/30/ajax%E3%80%81fetch%E3%80%81axios%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"ajax理解，即对ajax对自定义封装","text":"AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。 创建AJAX请求的步骤： 创建一个 XMLHttpRequest 对象。 在这个对象上使用 open 方法创建一个 HTTP 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。 在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。 当对象的属性和监听函数设置完成后，最后调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。 123456789101112131415161718192021222324const SERVER_URL = &quot;/server&quot;;let xhr = new XMLHttpRequest();// 创建 Http 请求xhr.open(&quot;GET&quot;, url, true);// 设置状态监听函数xhr.onreadystatechange = function() { if (this.readyState !== 4) return; // 当请求成功时 if (this.status === 200) { handle(this.response); } else { console.error(this.statusText); }};// 设置请求失败时的监听函数xhr.onerror = function() { console.error(this.statusText);};// 设置请求头信息xhr.responseType = &quot;json&quot;;xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);// 发送 Http 请求xhr.send(null);复制代码 使用Promise封装AJAX：123456789101112131415161718192021222324252627282930// promise 封装实现：function getJSON(url) { // 创建一个 promise 对象 let promise = new Promise(function(resolve, reject) { let xhr = new XMLHttpRequest(); // 新建一个 http 请求 xhr.open(&quot;GET&quot;, url, true); // 设置状态的监听函数 xhr.onreadystatechange = function() { if (this.readyState !== 4) return; // 当请求成功或失败时，改变 promise 的状态 if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; // 设置错误监听函数 xhr.onerror = function() { reject(new Error(this.statusText)); }; // 设置响应的数据类型 xhr.responseType = &quot;json&quot;; // 设置请求头信息 xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); // 发送 http 请求 xhr.send(null); }); return promise;} 原文地址","link":"/note/2022/03/29/ajax%E7%90%86%E8%A7%A3%EF%BC%8C%E5%8D%B3%E5%AF%B9ajax%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B0%81%E8%A3%85/"},{"title":"高频手写实现","text":"instanceof instanceof运算符用于检查构造函数的prototype是否在某个实例对象中存在。 所以只要遍历实例对象的原型链，挨个往上查找看是否有与Fn的prototype相等的原型，直到最顶层Object还找不到，那么就返回false。 实现遍历实现1234567891011121314function _instanceof(custructor, obj) { // 必须是对象或者函数 if (!(obj &amp;&amp; ['object', 'function'].includes(typeof obj))) { return false } let prototype = custructor.prototype let __proto__ = obj while (__proto__ = Object.getPrototypeOf(__proto__)) { if (__proto__ === prototype) { return true } } return false} 递归实现12345678910function _instanceof(custructor,obj){ if (!(obj &amp;&amp; ['object', 'function'].includes(typeof obj))) { return false } let proto = Object.getPrototypeOf(obj); let prototype = custructor.prototype; if(proto === null) return false; if(proto === prototype) return true; return _instanceof(custructor, proto)} JSON.stringifyJSON.stringify()将值转换为相应的 JSON 格式： 转换值如果有 toJSON() 方法，该方法定义什么值将被序列化。 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。 undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如JSON.stringify(function(){}) or JSON.stringify(undefined). 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。 所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。 Date 日期调用了 toJSON() 将其转换为了 string 字符串（同 Date.toISOString()），因此会被当做字符串处理。 NaN 和 Infinity 格式的数值及 null 都会被当做 null。 其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354if (!window.JSON) { JSON = { parse: function(jsonStr) { return eval('(' + jsonStr + ')'); }, stringify: function(jsonObj) { var result = '', curVal; if (jsonObj === null) { return String(jsonObj); } //处理引用数据 switch (Object.prototype.toString.call(jsonObj)) { case '[object Array]': result += '['; for (var i = 0, len = jsonObj.length; i &lt; len; i++) { curVal = JSON.stringify(jsonObj[i]); // 递归处理子集 result += (curVal === undefined ? null : curVal) + &quot;,&quot;; } if (result !== '[') { result = result.slice(0, -1); } result += ']'; return result; case '[object Date]': return '&quot;' + (jsonObj.toJSON ? jsonObj.toJSON() : jsonObj.toString()) +'&quot;'; case '[object RegExp]': return &quot;{}&quot;; case '[object Object]': result += '{'; for (i in jsonObj) { if (jsonObj.hasOwnProperty(i)) { curVal = JSON.stringify(jsonObj[i]); if (curVal !== undefined) { result += '&quot;' + i + '&quot;:' + curVal + ','; } } } if (result !== '{') { result = result.slice(0, -1); } result += '}'; return result; case '[object String]': return '&quot;' + jsonObj.toString() + '&quot;'; case '[object Number]': if(!isNaN(jsonObj)) return jsonObj case '[object Boolean]': return jsonObj.toString(); } } };} Promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217// 判断变量否为functionconst isFunction = (variable) =&gt; typeof variable === &quot;function&quot;;// 定义Promise的三种状态常量// promise状态只能在resolve与reject中改变且只改变一次// 添加状态（只能由PENDING-&gt;FULFILLED/REJECTED ,不可逆）const PENDING = &quot;PENDING&quot;; // 执行中const FULFILLED = &quot;FULFILLED&quot;; // 成功const REJECTED = &quot;REJECTED&quot;; // 失败class MyPromise { _status = PENDING; // 添加返回结果 _value = undefined; // 添加成功回调函数队列 _fulfilledQueues = []; // 添加失败回调函数队列 _rejectedQueues = []; constructor(handle) { if (!isFunction(handle)) { throw new Error(&quot;MyPromise must accept a function as a parameter&quot;); } // 执行handle try { // class中的function的prototype为undefind，需要bind处理 handle(this._resolve.bind(this), this._reject.bind(this)); } catch (err) { this._reject(err); } } // 添加resovle时执行的函数 _resolve(val) { const run = () =&gt; { if (this._status !== PENDING) return; this._status = FULFILLED; // 在status为pending时改变状态 // 依次执行成功队列中的函数，并清空队列 const runFulfilled = (value) =&gt; { let cb; while ((cb = this._fulfilledQueues.shift())) { cb(value); } }; // 依次执行失败队列中的函数，并清空队列 const runRejected = (error) =&gt; { let cb; while ((cb = this._rejectedQueues.shift())) { cb(error); } }; /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后, 当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态 */ if (val instanceof MyPromise) { val.then( (value) =&gt; { this._value = value; runFulfilled(value); }, (err) =&gt; { this._value = err; runRejected(err); } ); } else { this._value = val; runFulfilled(val); } }; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run, 0); } // 添加reject时执行的函数 _reject(err) { if (this._status !== PENDING) return; // 依次执行失败队列中的函数，并清空队列 const run = () =&gt; { this._status = REJECTED; // 在status为pending时改变状态 this._value = err; let cb; while ((cb = this._rejectedQueues.shift())) { cb(err); } }; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run, 0); } // 添加then方法 then(onFulfilled, onRejected) { const { _value, _status } = this; // then返回一个新的Promise对象 return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; { // 封装一个成功时执行的函数 let fulfilled = (value) =&gt; { try { if (!isFunction(onFulfilled)) { onFulfilledNext(value); } else { let res = onFulfilled(value); //这里返回.then中的结果 传入下一个then //判断then中的函数是否为Promise if (res instanceof MyPromise) { // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); } else { // 否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); } } } catch (err) { // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); } }; // 封装一个失败时执行的函数 let rejected = (error) =&gt; { try { if (!isFunction(onRejected)) { onRejectedNext(error); } else { let res = onRejected(error); if (res instanceof MyPromise) { // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); } else { // 否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); } } } catch (err) { // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); } }; switch (_status) { // 当状态为pending时，将then方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(fulfilled); this._rejectedQueues.push(rejected); break; // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(_value); break; case REJECTED: rejected(_value); break; } }); } // 添加catch方法 catch(onRejected) { return this.then(undefined, onRejected); } // 添加静态resolve方法 static resolve(value) { // 如果参数是MyPromise实例，直接返回这个实例 if (value instanceof MyPromise) return value; return new MyPromise((resolve) =&gt; resolve(value)); } // 添加静态reject方法 static reject(value) { return new MyPromise((resolve, reject) =&gt; reject(value)); } // 添加静态all方法 static all(list) { return new MyPromise((resolve, reject) =&gt; { /** * 返回值的集合 */ let values = []; let count = 0; for (let [i, p] of list.entries()) { // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(p).then( (res) =&gt; { values[i] = res; count++; // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled if (count === list.length) resolve(values); }, (err) =&gt; { // 有一个被rejected时返回的MyPromise状态就变成rejected reject(err); } ); } }); } // 添加静态race方法 static race(list) { return new MyPromise((resolve, reject) =&gt; { for (let p of list) { // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变 this.resolve(p).then( (res) =&gt; { resolve(res); }, (err) =&gt; { reject(err); } ); } }); } // 不管成功与失败都执行 finally(cb) { return this.then( (value) =&gt; MyPromise.resolve(cb()).then(() =&gt; value), (reason) =&gt; MyPromise.resolve(cb()).then(() =&gt; { throw reason; }) ); }} Promise.allPromise.all() 方法接收一个 promise 的 iterable 类型（注：Array，Map，Set 都属于 ES6 的 iterable 类型）的输入，并且只返回一个Promise实例， 那个输入的所有 promise 的 resolve 回调的结果是一个数组。这个Promise的 resolve 回调执行是在所有输入的 promise 的 resolve 回调都结束，或者输入的 iterable 里没有 promise 了的时候。它的 reject 回调执行是，只要任何一个输入的 promise 的 reject 回调执行或者输入不合法的 promise 就会立即抛出错误，并且 reject 的是第一个抛出的错误信息。 **Promise.resolve(value)**方法返回一个以给定值解析后的 Promise 对象。如果这个值是一个 promise ，那么将返回这个 promise ；如果这个值是 thenable（即带有 &quot;then&quot; 方法），返回的 promise 会“跟随”这个 thenable 的对象，采用它的最终状态；否则返回的 promise 将以此值完成。此函数将类 promise 对象的多层嵌套展平。 1234567891011121314Promise.myAll = function (promises) { return new Promise((resolve, reject) =&gt; { let values = [], len = promises.length, count = 0 for (let i = 0; i &lt; len; i++) { let item = promises[i] Promise.resolve(item).then(res=&gt;{ count+=1 values[i] = res if(count===len) resolve(values) }).catch(reject) } })} Promise.racePromise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。 1234567891011Promise.myRace = (promises) =&gt; { // 返回一个新的Promise return new Promise((rs, rj) =&gt; { promises.forEach((p) =&gt; { // 包装一下promises中的项，防止非Promise .then出错 // 只要有任意一个完成了或者拒绝了，race也就结束了 Promise.resolve(p).then(rs).catch(rj) }) })} 深拷贝12345678910111213141516//对象深克隆function deepClone(obj){ //处理obj为正则、原始数据、 if(typeof obj !== 'object') return obj; if(obj instanceof RegExp) return new RegExp(obj); if(obj instanceof Date) return new Date(obj); if(typeof obj === 'symbol') return Symbol(obj); let newObj = new obj.constructor(); for(let key in obj){ if(obj.hasOwnProperty(key)){ newObj[key] = deepClone(obj[key]) } } return newObj;} 实现new操作符原理及实现 call、applycall参数thisArg: 可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。没有传递它的第一个参数。如果没有传递第一个参数，this 的值将会被绑定为全局对象。 备注：在严格模式下，this 的值将会是 undefined。见下文。 返回值使用调用者提供的 this 值和参数调用该函数的返回值。若该方法没有返回值，则返回 undefined。 123456789101112Function.prototype.myCall = function(ctx, ...args){ // 简单处理未传ctx上下文，或者传的是null和undefined等场景 if (!ctx) { ctx = typeof window !== 'undefined' ? window : global } let fnName = Symbol() let obj = Object(ctx) obj[fnName] = this; let res = obj[fnName](...args) delete obj[fnName] return res} apply该方法的语法和作用与 call 方法类似，只有一个区别，就是 call 方法接受的是一个参数列表，而 apply 方法接受的是一个包含多个参数的数组。 123456789101112Function.prototype.myApply = function(ctx, args=[]){ // 简单处理未传ctx上下文，或者传的是null和undefined等场景 if (!ctx) { ctx = typeof window !== 'undefined' ? window : global } let fnName = Symbol() let obj = Object(ctx) obj[fnName] = this; let res = obj[fnName](...args) delete obj[fnName] return res} trimtrim 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR等） 12345678910111213 // 方法一 去除空格法(方式1)String.prototype.trim = function () { return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, ''); };// 方法二 去除空格法(方式1)const trim = (str) =&gt; { return str.replace(/^\\s*|\\s*$/g, '') } // 方法三 字符提取法(方式2) const trim = (str) =&gt; { return str.replace(/^\\s*(.*?)\\s*$/g, '$1') } Object.createObject.create() 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。 参数proto 新创建对象的原型对象。 propertiesObject 可选 如果该参数被指定且不为 undefined，则该传入对象的自有可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）将为新创建的对象添加指定的属性值和对应的属性描述符。这些属性对应于 Object.defineProperties() 的第二个参数。 返回值一个新对象，带着指定的原型对象及其属性。 123456789101112131415161718function ObjectCreate(proto, propertiesObject){ if (![ 'object', 'function' ].includes(typeof proto)) { throw new TypeError(`Object prototype may only be an Object or null: ${proto}`) } let Ctor = new Function() Ctor.prototype = proto const res = new Ctor() // 支持第二个参数 if (propertiesObject) { // Object.defineProperty的批量处理方法 Object.defineProperties(res, propertiesObject) } // 支持空原型 if (proto === null) { res.__proto__ = null } return res} reducereduce() 方法对数组中的每个元素按序执行一个由您提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。 第一次执行回调函数时，不存在“上一次的计算结果”。如果需要回调函数从数组索引为 0 的元素开始执行，则需要传递初始值。否则，数组索引为 0 的元素将被作为初始值 initialValue，迭代器将从第二个元素开始执行（索引为 1 而不是 0）。 参数 callbackFn 一个 “reducer” 函数，包含四个参数：previousValue：上一次调用 callbackFn 时的返回值。在第一次调用时，若指定了初始值 initialValue，其值则为 initialValue，否则为数组索引为 0 的元素 array[0]。currentValue：数组中正在处理的元素。在第一次调用时，若指定了初始值 initialValue，其值则为数组索引为 0 的元素 array[0]，否则为 array[1]。currentIndex：数组中正在处理的元素的索引。若指定了初始值 initialValue，则起始索引号为 0，否则从索引 1 起始。array：用于遍历的数组。 initialValue 可选 作为第一次调用 callback 函数时参数 previousValue 的值。若指定了初始值 initialValue，则 currentValue 则将使用数组第一个元素；否则 previousValue 将使用数组第一个元素，而 currentValue 将使用数组第二个元素。 1234567891011121314151617Array.prototype.myReduce = function(callbackFn, initialValue){ console.log(this) if (typeof callbackFn !== 'function') { throw `${callbackFn} is not a function` } let previousValue = this[0] , len = this.length , i = 1 ; if(initialValue){ previousValue = initialValue i = 0 } for(; i &lt; len; i++){ previousValue = callbackFn(previousValue, this[i] ,i , this) } return previousValue} 柯里化1234567891011121314151617181920212223242526 // 一function compose(...fns){ let len = fns.length; fns = [].slice.apply(fns) return function(...args){ if (len===0) return args if (len===1) return fns[0](...args) return fns.reduce((previousFn,currentFn)=&gt;{ if(typeof previousFn === 'function'){ return currentFn(previousFn(...args)) }else{ return currentFn(...args) } }) } } // 二 function compose2(...funcs) { if (funcs.length ===0) { return arg =&gt; arg } if (funcs.length ===1) { return funcs[0] } return funcs.reduce((a, b) =&gt; (...args) =&gt; b(a(...args))); } 数组去重123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** 数组去重**/let arr = [1,13,464,1311,3,4,1,1,474,6,4,317,3335,4,444,55,55];let arr2 =[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN','NaN', 0, 0, 'a', 'a',{name:'zhangsan'}, {name:'zhangsan'},{name:'李四'}]/**一 */// 通过arr.indexOf === i来判断function unique1(arr){ let res = []; for(let i=0;i&lt;arr.length;i++){ if(arr.indexOf(arr[i])===i){ res.push(arr[i]) } } return res;}//2 arr.indexOf(NaN)总是-1 ，不能找到数组中的NaN//[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, {…}, {…}] //NaN和object没有去重/**二 */// 通过es6 Setfunction unique2(arr){ return Array.from(new Set(arr));}//在Set中NaN===NaN// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {…}, {…}] //object没有去重/**三 */// 利用for嵌套for，然后splice去重（ES5中最常用）function unique3(arr){ for(var i=0;i&lt;arr.length;i++){ for(var j = i+1;j&lt;arr.length;j++){ if(arr[i]===arr[j]){ arr.splice(j,1) j-- } } } return arr}// [0, 1, 15, &quot;NaN&quot;, NaN, NaN, {…}, {…}, &quot;a&quot;, false, null, true, &quot;true&quot;, undefined] //NaN、object没有去重/**四 *///利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）function unique4(arr){ if(!Array.isArray(arr)) return arr; var res = [],obj = {}; for(var i = 0;i&lt;arr.length;i++){ if(!obj[arr[i]]){ res.push(arr[i]); obj[arr[i]] = true; } } return res;}/**五 *///利用includesfunction unique5(arr){ let res = []; for(var i=0;i&lt;arr.length;i++){ if(!res.includes(arr[i])){ res.push(arr[i]) } } return res;}// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {…}, {…}] //object没有去重/**六 *///利用hasOwnPropertyfunction unique6(arr){ let res = [],obj = {}; for(var i=0;i&lt;arr.length;i++){ if(!obj.hasOwnProperty(typeof arr[i] + arr[i])){ obj[typeof arr[i] + arr[i]] = true; res.push(arr[i]) } } return res}// 所有的都去重了（问题：object不管相不相等都会去重）let res = unique6(arr2)console.log(res,arr2.length,res.length) 多维数组扁平化Array.flat()flat() 方法是ES10提出的，它会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。（flat意为“水平的；平坦的”） 1arr.flat(Infinity) // 指定深度为无限 递归方式使用reduce拿到数组的当前值和前一项值，判断当前值是否为数组，初始值设置为[]，然后使用concat进行数组合并。 12345678const { isArray } = Arrayconst flat = (arr) =&gt; { if (isArray(arr)) { return arr.reduce((item, it) =&gt; { return item.concat(Array.isArray(it) ? flat(it) : it) }, []) }} 使用函数递归循环遍历数组，发现含有数组元素就进行递归处理，最终将数组转为一维数组。 12345678910const result = []function exec(arr) { arr.forEach(item =&gt; { if (Array.isArray(item)) { exec(item) } else { result.push(item) } })} 使用扩展运算符+concat()ES6新推出的扩展运算符能对数组进行降维处理（一次降一维），循环判断是否含有数组，进行concat合并。 123456function flatten(arr) { while (arr.some(item =&gt; Array.isArray(item))) { arr = [].concat(...arr) } return arr} 提取两个数组的相同元素12345678function getCommon&lt;T&gt;(arr1:Array&lt;T&gt;,arr2:Array&lt;T&gt;):Array&lt;T&gt;{ let res:Array&lt;T&gt; = [], len1:number = arr1.length for(let i=0;i&lt;len1;i++){ let item = arr1[i] if(arr2.includes(item)) res.push(item) } return res} 数组排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117let arr = [12, 4, 31, 65, 44, 6, 132, 1, 34, 65, 4, 64, 3, 13, 21, 31];//冒泡排序function sort(arr) { if(!Array.isArray(arr)) return; for (let i = 1; i &lt; arr.length; i++) { for (let j = 0; j &lt; arr.length - 1; j++) { if (arr[j + 1] &lt; arr[j]) { [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]] } } } return arr;}// console.log('sort',sort(arr))//快速排序function quickSort(arr) { if (!Array.isArray(arr)) return; if (arr.length &lt;= 1) return arr; let leftArr = []; let rightArr = []; let valueIndex = ~~(arr.length / 2); let piovt = arr.splice(valueIndex, 1)[0]; for (let i = 0; i &lt; arr.length; i++) { if (arr[i] &gt; piovt) { rightArr.push(arr[i]) } else { leftArr.push(arr[i]) } } return [...quickSort(leftArr), piovt, ...quickSort(rightArr)];}// console.log('quickSort',quickSort(arr))//插入排序function insertion(arr) { let current = 0, preIndex = 0; for (let i = 0; i &lt; arr.length; i++) { current = arr[i]; //当前 preIndex = i - 1; //上一个 while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) { arr[preIndex + 1] = arr[preIndex]; preIndex-- console.log(arr,preIndex+1,current) } arr[preIndex + 1] = current; } return arr;}var arr1 = [3, 5, 7, 1, 4, 56, 12, 78, 25, 0, 9, 8, 42, 37];console.log('insertion',insertion(arr1));//选择排序function selectSort(arr) { var len = arr.length; var minIndex; for (var i = 0; i &lt; len - 1; i++) { minIndex = i; for (var j = i + 1; j &lt; len; j++) { if (arr[minIndex] &gt; arr[j]) { minIndex = j; } } [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]] } return arr;}// console.log('selectSort',selectSort(arr1))//希尔排序function shellSort(arr) { var len = arr.length; for (var gap = ~~(len / 2); gap &gt; 0; gap = ~~(gap / 2)) { // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行 for (var i = gap; i &lt; len; i++) { var j = i; var current = arr[i]; while (j - gap &gt;= 0 &amp;&amp; current &lt; arr[j - gap]) { arr[j] = arr[j - gap]; j = j - gap; } arr[j] = current; } } return arr;}// console.log(shellSort(arr1))//归并排序function mergeSort(arr) { //采用自上而下的递归方法 var len = arr.length; if (len &lt; 2) { return arr; } var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));}function merge(left, right) { var result = []; while (left.length &amp;&amp; right.length) { // 不断比较left和right数组的第一项，小的取出存入res left[0] &lt; right[0] ? result.push(left.shift()) : result.push(right.shift()); } return result.concat(left, right);}// console.log(mergeSort(arr1))","link":"/note/2022/07/09/js%E9%AB%98%E9%A2%91%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0/"},{"title":"new运算符","text":"new运算符new的过程new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。 官方文档 1234567function Person(name){ this.name = name}let p = new Person(&quot;张三&quot;)console.log(typeof p) //objectconsole.log(typeof Person) //functionconsole.log(p) //{ name:&quot;张三&quot; } 创建一个对象； 1var obj = new Object() 将这个空对象的__proto__成员指向构造函数对象的prototype成员； 1obj._proto_ = Person.prototype 将构造函数的this指向obj，即在obj的作用域中调用Person函数； 1Person.call(obj); 如果该函数没有返回对象，则返回this。 如何new一个箭头函数的话，由于箭头函数没有自己的this，通过call()、apply()方法调用时，第一个参数会被忽略，箭头函数也没有prototype，所以new的第二和第三步就无法执行。 手写new12345678function myNew(func,...args){ //用Object.create以func.prototype问原型创建一个对象; const obj = Object.create(func.prototype) //将func的this指向obj const rel = fn.apply(obj,args) //返回一个对象，那么new 这个函数调用返回这个函数的返回对象，否则返回 new 创建的新对象 return rel instanceof Object ? rel : obj}","link":"/note/2022/03/26/new%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"npm run","text":"原文：npm scripts 使用指南 npm脚本npm 脚本是写在package.json文件里面scripts中的执行命令。 1234567{ // ... &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server --config webpack.config.js&quot; },} 这是一个package.jsong文件脚本命令的一个示例，scripts为一个对象，其中每项值都对应一个脚本命令。比如，dev命令对应的脚本是webpack-dev-server --config webpack.config.js。 命令行下使用npm run dev命令，就可以执行这段脚本。 使用不带任何参数的npm run就可以获得项目所有的脚本命令。 123456789$ npm run# 返回值如下Lifecycle scripts included in demo@1.0.0: test echo &quot;Error: no test specified&quot; &amp;&amp; exit 1available via `npm run-script`: dev webpack-dev-server --config webpack.config.js 项目是通过npm run dev 命令就可以启动，但直接输入webpack-dev-server --config webpack.config.js时终端就会返回bash: webpack-dev-server: command not found这样的提示，这是因为在全局变量中没有相应的配置。 npm run都做了什么每当我们在执行npm run时，npm就会到package.json中找对应的脚本命令，并会新建一个Shell，在这个Shell中执行指定的脚本。这个新建的Shell会将node_modules/.bin这个目录加入PATH变量中去，在执行结束后又会将PATH恢复回去。 所以在node_modules/.bin中的所有脚步都可以直接使用脚步名，不需要加上路径。比如：dev脚本命令 1&quot;dev&quot;: &quot;webpack-dev-server --config webpack.config.js&quot; 不用写成 1&quot;dev&quot;: &quot;./node_modules/.bin/webpack-dev-server --config webpack.config.js&quot; 由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。 npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败。 简写npm常用的简写 npm start === npm run start npm stop === npm run stop npm test === npm run test npm restart ===npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start npm默认值npm对start和install提供了默认值。只要在package.json中没有定义这两个命令,就会执行 12&quot;start&quot;: &quot;node server.js&quot;，&quot;install&quot;: &quot;node-gyp rebuild&quot; npm run start的默认值是node server.js，前提是项目根目录下有server.js这个脚本；npm run install的默认值是node-gyp rebuild，前提是项目根目录下有binding.gyp文件。 钩子npm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。 123&quot;prebuild&quot;: &quot;echo I run before the build script&quot;,&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;,&quot;postbuild&quot;: &quot;echo I run after the build script&quot; 用户执行npm run build的时候，会自动按照下面的顺序执行。 1npm run prebuild &amp;&amp; npm run build &amp;&amp; npm run postbuild 因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。 123&quot;clean&quot;: &quot;rimraf ./dist &amp;&amp; mkdir dist&quot;,&quot;prebuild&quot;: &quot;npm run clean&quot;,&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot; npm 默认提供下面这些钩子。 prepublish，postpublish preinstall，postinstall preuninstall，postuninstall preversion，postversion pretest，posttest prestop，poststop prestart，poststart prerestart，postrestart 自定义的脚本命令也可以加上pre和post钩子。比如，myscript这个脚本命令，也有premyscript和postmyscript钩子。不过，双重的pre和post无效，比如prepretest和postposttest是无效的。 npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。 12345678910111213const TARGET = process.env.npm_lifecycle_event;if (TARGET === 'test') { console.log(`Running the test task!`);}if (TARGET === 'pretest') { console.log(`Running the pretest task!`);}if (TARGET === 'posttest') { console.log(`Running the posttest task!`);} 注意，prepublish这个钩子不仅会在npm publish命令之前运行，还会在npm install（不带任何参数）命令之前运行。这种行为很容易让用户感到困惑，所以 npm 4 引入了一个新的钩子prepare，行为等同于prepublish，而从 npm 5 开始，prepublish将只在npm publish命令之前运行。 变量npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。 通过npm_package_前缀，npm 脚本可以获取到package.json里面的字段。比如。 1234567891011121314151617{ &quot;name&quot;: &quot;demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;config&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;xxx&quot; }, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server&quot;, &quot;d&quot;: &quot;npm run dev -- --config webpack.config.js&quot;, &quot;predev&quot;: &quot;echo I run before the build script&quot;, &quot;postdev&quot;: &quot;echo I run after the build script&quot; },} 变量npm_package_name返回demo，变量npm_package_version返回1.0.0，在代码中通过环境变量process.env.npm_package_xxx获取。如果是 Bash 脚本，可以用$npm_package_name和$npm_package_version取到这两个值。 12console.log(process.env.npm_package_name); // democonsole.log(process.env.npm_package_version); // 1.0.0 npm_package_前缀也支持嵌套的package.json字段。 1console.log(process.env.npm_package.config.type) //git 上面代码中，scripts字段的test脚本的值。 下面是另外一个例子。 123&quot;scripts&quot;: { &quot;install&quot;: &quot;foo.js&quot;} 上面代码中，npm_package_scripts_install变量的值等于foo.js。 然后，npm 脚本还可以通过npm_config_前缀，拿到 npm 的配置变量，即npm config get xxx命令返回的值。比如，当前模块的发行标签，可以通过npm_config_tag取到。 1&quot;view&quot;: &quot;echo $npm_config_tag&quot;, 注意，package.json里面的config对象，可以被环境变量覆盖。 12345{ &quot;name&quot; : &quot;foo&quot;, &quot;config&quot; : { &quot;port&quot; : &quot;8080&quot; }, &quot;scripts&quot; : { &quot;start&quot; : &quot;node server.js&quot; }} 上面代码中，npm_package_config_port变量返回的是8080。这个值可以用下面的方法覆盖。 1$ npm config set foo:port 80 最后，env命令可以列出所有环境变量。 1&quot;env&quot;: &quot;env&quot; 通配符由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符。 12&quot;lint&quot;: &quot;jshint *.js&quot;&quot;lint&quot;: &quot;jshint **/*.js&quot; 上面代码中，*表示任意文件名，**表示任意一层子目录。 如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。 1&quot;test&quot;: &quot;tap test/\\*.js&quot; 传参npm传参需要使用--标明，比如： 123&quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server&quot;,}, 在webpack-dev-server我想要指定配置config文件时: 1npm run dev -- --config webpack.config.js 执行顺序npm 脚本执行多个任务 并行执行（即同时的平行执行），使用&amp;符号:$ npm run script1.js &amp; npm run script2.js 继发执行，排队依次执行，执行成功才执行下一个，可以使用&amp;&amp;符号:$ npm run script1.js &amp;&amp; npm run script2.js","link":"/note/2022/03/27/npm-run/"},{"title":"tsconfig.json配置详情","text":"如果某目录下存在tsconfig.json文件，则表示这个目录是TypeScript项目的根目录。 在命令行中用tsc指令（不带文件名参考）编译TypeScript项目时,编译器会自动从目录中寻找tsconfig.json文件，并根据其中的配置信息对项目进行编译。 基本配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&quot;compilerOptions&quot;: { &quot;incremental&quot;: true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度 &quot;tsBuildInfoFile&quot;: &quot;./buildFile&quot;, // 增量编译文件的存储位置 &quot;diagnostics&quot;: true, // 打印诊断信息 &quot;target&quot;: &quot;ES5&quot;, // 目标语言的版本 &quot;module&quot;: &quot;CommonJS&quot;, // 生成代码的模板标准 &quot;outFile&quot;: &quot;./app.js&quot;, // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置&quot;module&quot;: &quot;AMD&quot;, &quot;lib&quot;: [&quot;DOM&quot;, &quot;ES2015&quot;, &quot;ScriptHost&quot;, &quot;ES2019.Array&quot;], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;, &quot;allowJS&quot;: true, // 允许编译器编译JS，JSX文件 &quot;checkJs&quot;: true, // 允许在JS文件中报错，通常与allowJS一起使用 &quot;outDir&quot;: &quot;./dist&quot;, // 指定输出目录 &quot;rootDir&quot;: &quot;./&quot;, // 指定输出文件目录(用于输出)，用于控制输出目录结构 &quot;declaration&quot;: true, // 生成声明文件，开启后会自动生成声明文件 &quot;declarationDir&quot;: &quot;./file&quot;, // 指定生成声明文件存放目录 &quot;emitDeclarationOnly&quot;: true, // 只生成声明文件，而不会生成js文件 &quot;sourceMap&quot;: true, // 生成目标文件的sourceMap文件 &quot;inlineSourceMap&quot;: true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中 &quot;declarationMap&quot;: true, // 为声明文件生成sourceMap &quot;typeRoots&quot;: [], // 声明文件目录，默认时node_modules/@types &quot;types&quot;: [], // 加载的声明文件包 &quot;removeComments&quot;:true, // 删除注释 &quot;noEmit&quot;: true, // 不输出文件,即编译后不会生成任何js文件 &quot;noEmitOnError&quot;: true, // 发送错误时不输出任何文件 &quot;noEmitHelpers&quot;: true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用 &quot;importHelpers&quot;: true, // 通过tslib引入helper函数，文件必须是模块 &quot;downlevelIteration&quot;: true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现 &quot;strict&quot;: true, // 开启所有严格的类型检查 &quot;jsx&quot;: &quot;preserve&quot;, // 指定 jsx 格式 &quot;alwaysStrict&quot;: true, // 在代码中注入'use strict' &quot;noImplicitAny&quot;: true, // 不允许隐式的any类型 &quot;strictNullChecks&quot;: true, // 不允许把null、undefined赋值给其他类型的变量 &quot;strictFunctionTypes&quot;: true, // 不允许函数参数双向协变 &quot;strictPropertyInitialization&quot;: true, // 类的实例属性必须初始化 &quot;strictBindCallApply&quot;: true, // 严格的bind/call/apply检查 &quot;noImplicitThis&quot;: true, // 不允许this有隐式的any类型 &quot;noUnusedLocals&quot;: true, // 检查只声明、未使用的局部变量(只提示不报错) &quot;noUnusedParameters&quot;: true, // 检查未使用的函数参数(只提示不报错) &quot;noFallthroughCasesInSwitch&quot;: true, // 防止switch语句贯穿(即如果没有break语句后面不会执行) &quot;noImplicitReturns&quot;: true, //每个分支都会有返回值 &quot;esModuleInterop&quot;: true, // 允许export=导出，由import from 导入 &quot;allowUmdGlobalAccess&quot;: true, // 允许在模块中全局变量的方式访问umd模块 &quot;moduleResolution&quot;: &quot;node&quot;, // 模块解析策略，ts默认用node的解析策略，即相对的方式导入 &quot;baseUrl&quot;: &quot;./&quot;, // 解析非相对模块的基地址，默认是当前目录 &quot;paths&quot;: { // 路径映射，相对于baseUrl // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置 &quot;jquery&quot;: [&quot;node_modules/jquery/dist/jquery.min.js&quot;] }, &quot;rootDirs&quot;: [&quot;src&quot;,&quot;out&quot;], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错 &quot;listEmittedFiles&quot;: true, // 打印输出文件 &quot;listFiles&quot;: true// 打印编译的文件(包括引用的声明文件)} tsconfig.json文件是 TypeScript 编译器的配置文件，TypeScript 编译器可以根据它的规则来对代码进行编译。 根选项include：指定被编译文件所在的目录。exclude：指定不需要被编译的目录。extends：指定要继承的配置文件。files：指定被编译的文件。references：项目引用，是 TS 3.0 中的一项新功能，它允许将 TS 程序组织成更小的部分。使用小技巧：在填写路径时 ** 表示任意目录， * 表示任意文件。 compilerOptions 定义项目的运行时期望、JavaScript 的发出方式和位置以及与现有 JavaScript 代码的集成级别。 项目选项incremental：是否启用增量编译，指再次编译时只编译增加的内容，默认：false。target：指定ts编译成ES的版本。module：指定编译后代码使用的模块化规范。lib：指定项目运行时使用的库。outDir：指定编译后文件所在目录。outFile：将代码编译合并成一个文件，默认将所有全局作用域中的代码合并成一个文件。rootDir：指定输入文件的根目录，默认情况下当前的项目目录为根目录。allowJs：是否对js文件进行编译，默认：false。checkJs：是否检查js代码是否符合语法规范，当使用checkJs，必须使用allowJs，默认：false。removeComments：是否移除注释，默认：falsenoEmit：不生成编译后的文件，默认：false。jsx：指定JSX代码生成用于的开发环境。plugins：在编辑器中运行的语言服务插件列表。declaration：是否生成相应的 .d.ts 声明文件，默认：false。declarationMap：是否为每个对应的 .d.ts 文件生成一个 Map 文件，使用该功能时，需要declaration或composite配合一起使用，默认：false。sourceMap：是否生成相应的Map映射的文件，默认：false。composite：是否开启项目编译，开启该功能，将会生成被编译文件所在的目录，同时开启declaration、declarationMap和incremental，默认：false。tsBuildInfoFile：指定增量编译信息文件的位置，使用该功能时，必须开启incremental选项。importHelpers：是否将辅助函数从 tslib 模块导入，默认：false。downlevelIteration：是否用于转换为旧版本的 JS 提供可迭代对象的全面支持，默认：false。isolatedModules：是否将每个文件转换为单独的模块，默认：false。 严格检查strict：是否启动所有严格检查的总开关，默认：false，启动后将开启所有的严格检查选项。alwaysStrict：是否以严格模式解析，并为每个源文件发出”use strict”，默认：false。noImplicitAny：是否禁止隐式的any类型，默认：false。noImplicitThis：是否禁止不明确类型的this，默认：false。strictNullChecks：是否启用严格的空检查，默认：false。strictBindCallApply：是否在函数上启用严格的’bind’， ‘call’和’apply’方法，默认：false。strictFunctionTypes：是否启用对函数类型的严格检查，默认：false。strictPropertyInitialization：是否启用严格检查类的属性初始化，默认：false。 模块解析选项moduleResolution：指定模块解析策略，node或classicbaseUrl：用于解析非绝对模块名的基本目录，相对模块不受影响。paths：用于设置模块名称基于baseUrl的路径映射关系。rootDirs：将多个目录放在一个虚拟目录下，运行编译后文件引入的位置发生改变，也不会报错。typeRoots：指定声明文件或文件夹的路径列表types：用来指定需要包含的模块，并将其包含在全局范围内。allowSyntheticDefaultImports：是否允许从没有默认导出的模块中默认导入，默认：false。esModuleInterop：是否通过为所有导入模块创建命名空间对象，允许CommonJS和ES模块之间的互操作性，开启改选项时，也自动开启allowSyntheticDefaultImports选项，默认：false。preserveSymlinks：是否不解析符号链接的真实路径，这是为了在 Node.js 中反映相同的标志，默认：false。allowUmdGlobalAccess：允许您从模块文件内部访问作为全局变量的 UMD 导出，如果不使用该选项，从 UMD 模块导出需要一个导入声明，默认：false。 Map选项sourceRoot：指定调试器应定位 TypeScript 文件而不是相对源位置的位置。mapRoot：指定调试器定位Map文件的位置，而不是生成的位置。inlineSourceMap：是否将Map文件内容嵌套到 JS 文件中，这会导致 JS 文件变大，但在某些情况下会很方便，默认：false。inlineSources：是否将 .ts 文件的原始内容作为嵌入字符串包含在 .map 文件中，默认：false。 附加检查noUnusedLocals：是否检查未使用的局部变量，默认：false。noUnusedParameters：是否检查未使用的参数，默认：false。noImplicitReturns：检查函数是否不含有隐式返回值，默认：false。noImplicitOverride：是否检查子类继承自基类时，其重载的函数命名与基类的函数不同步问题，默认：false。noFallthroughCasesInSwitch：检查switch中是否含有case没有使用break跳出，默认：false。noUncheckedIndexedAccess：是否通过索引签名来描述对象上有未知键但已知值的对象，默认：false。noPropertyAccessFromIndexSignature：是否通过” . “(obj.key) 语法访问字段和”索引”( obj[“key”])， 以及在类型中声明属性的方式之间的一致性，默认：false。 实验选项experimentalDecorators：是否启用对装饰器的实验性支持，装饰器是一种语言特性，还没有完全被 JavaScript 规范批准，默认：false。emitDecoratorMetadata：为装饰器启用对发出类型元数据的实验性支持，默认：false。 高级选项allowUnreachableCode：是否允许无法访问的代码(undefined / true / false)，默认：undefined。 undefined：向编辑提供建议作为警告。true：未使用的标签被忽略。false：引发有关未使用标签的编译器错误。 allowUnusedLabels：是否允许未使用的标签(undefined / true / false)，默认：undefined。 undefined：向编辑提供建议作为警告。true：未使用的标签被忽略。false：引发有关未使用标签的编译器错误。 assumeChangesOnlyAffectDirectDependencies是否避免重新检查/重建所有真正可能受影响的文件，而只会重新检查/重建已更改的文件以及直接导入它们的文件，默认：false。charset：字符集(已弃用)，默认：utf8declarationDir：提供一种方法来配置发出声明文件的根目录。diagnostics：用于输出用于调试的诊断信息disableReferencedProjectLoad：是否禁用所有可用项目加载到内存中，默认：false。disableSizeLimit：为了避免在处理非常大的 JS 项目时可能出现的内存膨胀问题，TS 将分配的内存量有一个上限，默认：false。disableSolutionSearching：在编辑器中搜索查找所有引用或跳转到定义等功能时，禁止包含复合项目，默认：false。disableSourceOfProjectReferenceRedirect：是否禁用项目引用源重定向，默认：false。emitBOM：控制TypeScript在写输出文件时是否发出字节顺序标记(BOM)，默认：false。emitDeclarationOnly：是否只发出.d.ts 文件，不发出.js 文件，使用该选项时，需要配合 declaration 或 composite 一起使用，默认：false。explainFiles：解释文件，此选项用于调试文件如何成为编译的一部分，默认：false。extendedDiagnostics：是否查看 TS 在编译时花费的时间，默认：false。forceConsistentCasingInFileNames：是否区分文件系统大小写规则，默认：false。generateCpuProfile：在编译阶段让 TS 发出 CPU 配置文件，只能通过终端或 CLI 调用 –generateCpuProfile tsc-output.cpuprofile 。importsNotUsedAsValues：此标志控制如何 import 工作方式，有 3 个不同的选项：remove、preserve 和 error 。jsxFactory：当使用经典的JSX运行时编译JSX元素时，更改.js文件中调用的函数，默认：React.createElement 。jsxFragmentFactory：指定 JSX 片段工厂函数在指定了 jsxFactory 编译器选项的情况下针对 react JSX 发出时使用。jsxImportSource：当在TS 4.1中使用 jsx 作为 react-jsx 或 react-jsxdev 时，声明用于导入jsx和jsxs工厂函数的模块说明符。keyofStringsOnly：当应用具有字符串索引签名的类型时，此标志将类型操作符的键值更改为返回 string 而不是string | number，已弃用，默认：false。listEmittedFiles：是否将编译部分生成的文件的名称打印到终端，默认：false。listFiles：是否打印编译文件部分的名称，默认：false。maxNodeModuleJsDepth：在node_modules下搜索并加载JavaScript文件的最大依赖深度，默认：0 。newLine：指定发出文件时要使用的换行规则，CRLF (dos) 或 LF (unix)。noEmitHelpers：是否使用全局作用域助手函数提供实现，并完全关闭助手函数的发出，而不是使用 importhelper 来导入助手函数，默认：false。noEmitOnError：有错误时不进行编译，默认：false。noErrorTruncation：是否禁止截断错误消息，已弃用，默认：false。noImplicitUseStrict：是否禁止无隐式严格模式，默认：false。noLib：是否禁止自动包含任何库文件，默认：false。noResolve：是否禁用析后的文件添加到程序中；默认情况下，TS 会检查 import 和 reference 指令的初始文件集，并将这些解析后的文件添加到你的程序中，默认：false。noStrictGenericChecks：是否禁用严格的泛型检查，默认：false。out：该选项以不可预测或一致的方式计算最终文件位置，已弃用，preserveConstEnums：是否禁止删除枚举常量生成代码中的声明，默认：false。reactNamespace：React命名空间，使用 jsxFactory 来代替。resolveJsonModule：是否解析 JSON 模块，默认：false。skipDefaultLibCheck：是否跳过默认库声明文件的类型检查，默认：false。skipLibCheck：是否跳过声明文件的类型检查，这可以在编译期间以牺牲类型系统准确性为代价来节省时间，默认：false。stripInternal：是否禁止 JSDoc 注释中带有@internal注释的代码发出声明，默认：false。suppressExcessPropertyErrors：是否禁用报告过多的属性错误，默认：false。suppressImplicitAnyIndexErrors：是否抑制隐式any索引的错误，默认：false。traceResolution：当尝试调试未包含模块的原因时。启用该选项让 TypeScript 打印有关每个处理文件的解析过程的信息，默认：false。useDefineForClassFields：此标志用作迁移到即将推出的类字段标准版本的一部分，默认：false。 命令行preserveWatchOutput：是否在监视模式下保留过时的控制台输出，而不是每次发生更改时都清除屏幕，默认：false。pretty：是否使用颜色对上下文错误和消息进行样式化，默认：true。 watchOptions配置 TypeScript 的 –watch工作方式。 监视选项watchFile：监视单个文件的策略，默认：useFsEventsfixedPollingInterval：以固定时间间隔每秒多次检查每个文件的更改。priorityPollingInterval：每秒多次检查每个文件的更改，但使用启发式方法检查某些类型的文件的频率低于其他文件。dynamicPriorityPolling：使用动态队列，其中不经常修改的文件将不那么频繁地检查。useFsEvents：尝试使用操作系统/文件系统的本机事件进行文件更改。useFsEventsOnParentDirectory：尝试使用操作系统/文件系统的本机事件来监听文件父目录的变化。watchDirectory：在缺乏递归文件监视功能的系统下如何监视整个目录树的策略，默认：useFsEventsfixedPollingInterval：以固定时间间隔每秒多次检查每个目录的变化。dynamicPriorityPolling：使用动态队列，其中不经常修改的目录将不那么频繁地检查。useFsEvents：尝试使用操作系统/文件系统的本机事件进行目录更改。fallbackPolling：使用文件系统事件时，此选项指定当系统用完本机文件观察器和/或不支持本机文件观察器时使用的轮询策略，默认：dynamicPriorityPollingfixedPollingInterval：以固定时间间隔每秒多次检查每个文件的更改。priorityPollingInterval：每秒多次检查每个文件的更改，但使用启发式方法检查某些类型的文件的频率低于其他文件。dynamicPriorityPolling：使用动态队列，其中不经常修改的文件将不那么频繁地检查。synchronousWatchDirectory：禁用对目录的延迟监视。synchronousWatchDirectory：在本机不支持递归观看的平台上同步调用回调，并更新目录观察者的状态，默认：false。excludeDirectories：使用排除目录来大幅减少 –watch 期间被监视的文件数量.excludeFiles：使用excludeFiles从被监视的文件中删除一组特定的文件。 typeAcquisition类型获取仅对 JavaScript 项目很重要。 类型获取 enable：提供在 JavaScript 项目中禁用类型获取的配置，默认：false。include：使用 include 来指定应从绝对类型中使用哪些类型。exclude：提供用于禁用 JavaScript 项目中某个模块的类型获取的配置disableFilenameBasedTypeAcquisition：是否禁用基于文件名的类型获取，TypeScript 的类型获取可以根据项目中的文件名推断应该添加哪些类型，默认：false。 原文连接","link":"/note/2022/04/14/tsconfig-json%E9%85%8D%E7%BD%AE%E8%AF%A6%E6%83%85/"},{"title":"vue-router面试题","text":"路由重定向的方法 第一种 在路由列表中添加redirect，redirect为重定向的路径名 12345const router = new VueRouter({ routes: [ { path: '/a', redirect: '/b' } ]}) 第二种 在路由列表中添加redirect，redirect为一个对象{name:'xxx'} 12345const router = new VueRouter({ routes: [ { path: '/a', redirect: { name: 'foo' }} ]}) 第三种方法 在路由列表中添加redirect，redirect为一个方法，方法有一个to参数，表示跳转路由的信息 123456789101112131415161718const router = new VueRouter({ routes: [ { path: '/a', redirect: to =&gt;{ // 方法接收 目标路由 作为参数 // return 重定向的 字符串路径/路径对象 const { hash, params, query } = to if (query.to === 'foo') { return { path: '/foo', query: null } }else{ return '/b' } } } ]}) 如何配置404 Vue-router 3.x 1234567const router = new VueRouter({ routes: [ { path: '*', redirect: {path: '/404'} } ]}) Vue-router 4.x 123456const routes = [ // 将匹配所有内容并将其放在 `$route.params.pathMatch` 下 { path: '/:pathMatch(.*)*', name: 'NotFound', component: NotFound }, // 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下 { path: '/user-:afterUser(.*)', component: UserGeneric },] 切换路由时，需要保存草稿的功能，怎么实现呢？ 123&lt;keep-alive :include=&quot;include&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; 其中include可以是个数组，数组内容为路由的name选项的值。 路由有几种模式？说说它们的区别？ hash: 兼容所有浏览器，包括不支持 HTML5 History Api 的浏览器，例http://www.abc.com/#/index，hash值为#/index， hash的改变会触发hashchange事件，通过监听hashchange事件来完成操作实现前端路由。hash值变化不会让浏览器向服务器请求。 123456// 监听hash变化，点击浏览器的前进后退会触发window.addEventListener('hashchange', function(event){ let newURL = event.newURL; // hash 改变后的新 url let oldURL = event.oldURL; // hash 改变前的旧 url},false)复制代码 history: 兼容能支持 HTML5 History Api 的浏览器，依赖HTML5 History API来实现前端路由。没有#，路由地址跟正常的url一样，但是初次访问或者刷新都会向服务器请求，如果没有请求到对应的资源就会返回404，所以路由地址匹配不到任何静态资源，则应该返回同一个index.html 页面，需要在nginx中配置。 abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。 路由守卫 全局前置守卫beforeEach 1234router.beforeEach((to, from, next) =&gt; { // ... next()}) 全局解析守卫beforeResolve，只接受两个参数to，from 1234router.beforeResolve((to, from) =&gt; { // ...}) 全局后置钩子afterEach 你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身： 1234router.afterEach((to, from) =&gt; { // ... next()}) 路由独享守卫beforeEnter 123456789routes: [ { path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; { // ... } }] 组件内的守卫 beforeRouteEnter beforeRouteUpdate (2.2 新增) beforeRouteLeave 123456789101112131415161718const Foo = { template: `...`, beforeRouteEnter(to, from, next) { // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 }, beforeRouteUpdate(to, from, next) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` }, beforeRouteLeave(to, from, next) { // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` }} beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。 不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。 12345beforeRouteEnter (to, from, next) { next(vm =&gt; { // 通过 `vm` 访问组件实例 })} 讲一下导航守卫的三个参数的含义？每个守卫方法接收三个参数： to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。 next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。 next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。 next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。 确保 next 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。 路由导航的解析流程 导航被触发。 在失活的组件里调用 beforeRouteLeave 守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫(2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。 12345beforeRouteEnter(to, from, next) { next(vm =&gt; { //通过vm访问组件实例 })}, 路由导航守卫和Vue实例生命周期钩子函数的执行顺序？路由导航守卫都是在Vue实例生命周期钩子函数之前执行的。 router-link&lt;router-link&gt;是Vue-Router的内置组件，在具有路由功能的应用中作为声明式的导航使用。 &lt;router-link&gt;有8个props，其作用是： to：必填，表示目标路由的链接。当被点击后，内部会立刻把to的值传到router.push() ，所以这个值可以是一个字符串或者是描述目标位置的对象。 123456&lt;router-link to=&quot;home&quot;&gt;Home&lt;/router-link&gt;&lt;router-link :to=&quot;'home'&quot;&gt;Home&lt;/router-link&gt;&lt;router-link :to=&quot;{ path: 'home' }&quot;&gt;Home&lt;/router-link&gt;&lt;router-link :to=&quot;{ name: 'user', params: { userId: 123 }}&quot;&gt;User&lt;/router-link&gt;&lt;router-link :to=&quot;{ path: 'user', query: { userId: 123 }}&quot;&gt;User&lt;/router-link&gt;复制代码 注意path存在时params不起作用，只能用query replace：默认值为false，若设置的话，当点击时，会调用router.replace()而不是router.push()，于是导航后不会留下 history 记录。 append：设置 append 属性后，则在当前 (相对) 路径前添加基路径。 tag：让&lt;router-link&gt;渲染成tag设置的标签，如tag:'li,渲染结果为&lt;li&gt;foo&lt;/li&gt;。 active-class：默认值为router-link-active,设置链接激活时使用的 CSS 类名。默认值可以通过路由的构造选项 linkActiveClass 来全局配置。 exact-active-class：默认值为router-link-exact-active,设置链接被精确匹配的时候应该激活的 class。默认值可以通过路由构造函数选项 linkExactActiveClass 进行全局配置的。 exact 1234567：是否精确匹配，默认为false。```xml&lt;!-- 这个链接只会在地址为 / 的时候被激活 --&gt;&lt;router-link to=&quot;/&quot; exact&gt;&lt;/router-link&gt;复制代码 event：声明可以用来触发导航的事件。可以是一个字符串或是一个包含字符串的数组，默认是click。 如何在组件中监听路由参数变化？有两种方法可以监听路由参数的变化，但是只能用在包含&lt;router-view /&gt;的组件内。 第一种 12345watch:{ '$route':function(to, from){ .... }} 第二种 123beforeRouteUpdate(to, from, next){ ....} 切换路由后，新页面要滚动到顶部或者原来的位置在创建router实例时，可以传入scrollBehavir一个函数 123456789101112const router = new Router({ mode: 'history', base: process.env.BASE_URL, routes, scrollBehavior(to, from, savedPosition) { if (savedPosition) { return savedPosition; } else { return { x: 0, y: 0 }; } }}); 嵌套组件的使用场景做个管理系统，顶部栏和左侧菜单栏是全局通用的，那就应该放在父路由，而右下的页面内容部分放在子路由。 比如在app.vue文件中 123456&lt;template&gt; &lt;div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;复制代码 在layout.vue文件中 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;div&gt; //...头部导航 &lt;/div&gt; &lt;div&gt; //...侧边栏导航 &lt;/div&gt; &lt;div&gt; //...主内容 &lt;router-view/&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template复制代码 在routes.js文件中 12345678910111213141516171819202122function load(component) { return resolve =&gt; require([`views/${component}`], resolve);}const routes=[ { path: '/', redirect: '/home', name: 'layout', component: load('layout'), children: [ { path: '/home', name: 'home', component: load('home'), meta: { title: '首页' }, }, ] }]复制代码 然后layout页面就渲染在app.vue文件中的&lt;router-view/&gt;上。home页面就渲染在layout.vue文件夹中的&lt;router-view/&gt;上。 什么是命名视图？有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar (侧导航) 和 main (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。 123&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt; 一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置 (带上 s)： 123456789101112const router = new VueRouter({ routes: [ { path: '/', components: { default: Foo, a: Bar, b: Baz } } ]}) 如何获取路由传过来的参数？路由有三种传参方式，获取方式各不相同。 meta：路由元信息，写在routes配置文件中。 12345678{ path: '/home', name: 'home', component: load('home'), meta: { title: '首页' },}, 通过this.$route.meta.title获取 query 1234567this.$route.push({ path:'/home', query:{ userId:123 }})复制代码 浏览器地址：http://localhost:8036/home?userId=123 获取方式：this.$route.query.userId params:这个方式比较麻烦。 首先要在地址上做配置 12345678{ path: '/home/:userId', name: 'home', component: load('home'), meta: { title: '首页' },}, 访问传参 12const userId = '123'this.$router.push({ name: 'home', params: { userId } }) 注意用params传参，只能用命名的路由（用name访问），如果用path，params不起作用。 this.$router.push({ path: '/home', params: { userId }})不生效。 浏览器地址：http://localhost:8036/home/123 获取方式：this.$route.params.userId 路由组件和路由为什么解耦，怎么解耦？因为在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性，所有要解耦。 耦合如以下代码所示。Home组件只有在 1http://localhost:8036/home/123 URL上才能使用。 123456789const Home = { template: '&lt;div&gt;User {{ $route.params.id }}&lt;/div&gt;'}const router = new VueRouter({ routes: [ { path: '/home/:id', component: Home } ]})复制代码 使用 props 来解耦 props为true，route.params将会被设置为组件属性。 props为对象，则按原样设置为组件属性。 props为函数，http://localhost:8036/home?id=123,会把123传给组件Home的props的id。 1234567891011121314151617const Home = { props: ['id'], template: '&lt;div&gt;User {{ id }}&lt;/div&gt;'}const router = new VueRouter({ routes: [ { path: '/home/:id', component: Home, props: true}, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： { path: '/home/:id', components: { default: Home, sidebar: Sidebar }, props: { default: true, sidebar: false } } { path: '/home', component: Home, props: {id:123} }, { path: '/home', component: Home, props: (route) =&gt; ({ id: route.query.id }) }, ]}) active-class是那个组件的属性&lt;router-link/&gt;组件的属性，设置链接激活时使用的 CSS 类名。默认值可以通过路由的构造选项 linkActiveClass 来全局配置。 在vue组件中怎么获取到当前的路由信息？通过this.$route来获取 动态加载路由？使用Router的实例方法addRoutes来实现动态加载路由，一般用来实现菜单权限。 使用时要注意，静态路由文件中不能有404路由，而要通过addRoutes一起动态添加进去。 1234567891011121314151617181920const routes = [ { path: '/overview', name: 'overview', component: () =&gt; import('@/views/account/overview/index'), meta: { title: '账户概览', pid: 869, nid: 877 }, }, { path: '*', redirect: { path: '/' } }]vm.$router.options.routes.push(...routes);vm.$router.addRoutes(routes); 怎么实现路由懒加载呢？123456789101112131415function load(component) { //return resolve =&gt; require([`views/${component}`], resolve); return () =&gt; import(`views/${component}`);}const routes = [ { path: '/home', name: 'home', component: load('home'), meta: { title: '首页' }, },] 路由之间是怎么跳转的？有哪些方式？声明式 通过使用内置组件&lt;router-link :to=&quot;/home&quot;&gt;来跳转 编程式 通过调用router实例的push方法router.push({ path: '/home' })或replace方法router.replace({ path: '/home' }) 如果vue-router使用history模式，部署时要注意什么？要注意404的问题，因为在history模式下，只是动态的通过js操作window.history来改变浏览器地址栏里的路径，并没有发起http请求，当直接在浏览器里输入这个地址的时候，就一定要对服务器发起http请求，但是这个目标在服务器上又不存在，所以会返回404。 所以要在Ngnix中将所有请求都转发到index.html上就可以了。 123456location / { try_files $uri $uri/ @router index index.html;}location @router { rewrite ^.*$ /index.html last;} route和router有什么区别？route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。 而router是“路由实例对象”，包括了路由的跳转方法，钩子函数等。 Vue路由怎么跳转打开新窗口？12345678const obj = { path: xxx,//路由地址 query: { mid: data.id//可以带参数 }};const {href} = this.$router.resolve(obj);window.open(href, '_blank');","link":"/note/2022/07/18/vue-router%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"vuex面试题","text":"什么是VuexVuex 是一个专为 Vue.js 应用程序开发的状态管理插件。它采用集中式存储管理应用的所有组件的状态，而更改状态的唯一方法是提交mutation，例this.$store.commit('SET_VIDEO_PAUSE', video_pause，SET_VIDEO_PAUSE为mutations属性中定义的方法 。 Vuex解决了什么问题？解决两个问题 多个组件依赖于同一状态时，对于多层嵌套的组件的传参将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。 来自不同组件的行为需要变更同一状态。以往采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。 什么时候用Vuex一下两种场景： 多个组件依赖于同一个状态时。 来自不同组件的行为需要变更同一状态。 vuex的5个核心属性state、getters、mutations、actions、modules Vuex中状态储存在哪里，怎么改变它？存储在state中，改变Vuex中的状态的唯一途径就是显式地提交 (commit) mutation。 Vuex中状态是对象时，使用时要注意什么？因为对象是引用类型，复制后改变属性还是会影响原始数据，这样会改变state里面的状态，是不允许，所以先用深度克隆复制对象，再修改。 怎么在组件中批量使用Vuex的state状态？使用mapState辅助函数, 利用对象展开运算符将state混入computed对象中 123456import {mapState} from 'vuex'export default{ computed:{ ...mapState(['price','number']) }} Vuex中要从state派生一些状态出来，且多个组件使用它，该怎么做，？使用getter属性，相当Vue中的计算属性computed，只有原状态改变派生状态才会改变。 getter接收两个参数，第一个是state，第二个是getters(可以用来访问其他getter)。 123456789101112131415const store = new Vuex.Store({ state: { price: 10, number: 10, discount: 0.7, }, getters: { total: state =&gt; { return state.price * state.number }, discountTotal: (state, getters) =&gt; { return state.discount * getters.total } },}); 然后在组件中可以用计算属性computed通过this.$store.getters.total这样来访问这些派生转态。 12345678computed: { total() { return this.$store.getters.total }, discountTotal() { return this.$store.getters.discountTotal }} 怎么通过getter来实现在组件内可以通过特定条件来获取state的状态？通过让getter返回一个函数，来实现给getter传参。然后通过参数来进行判断从而获取state中满足要求的状态。 12345678910111213const store = new Vuex.Store({ state: { todos: [ { id: 1, text: '...', done: true }, { id: 2, text: '...', done: false } ] }, getters: { getTodoById: (state) =&gt; (id) =&gt;{ return state.todos.find(todo =&gt; todo.id === id) } },}); 然后在组件中可以用计算属性computed通过this.$store.getters.getTodoById(2)这样来访问这些派生转态。 12345678computed: { getTodoById() { return this.$store.getters.getTodoById },}mounted(){ console.log(this.getTodoById(2).done)//false} 怎么在组件中批量使用Vuex的getter属性使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中 123456import {mapGetters} from 'vuex'export default{ computed:{ ...mapGetters(['total','discountTotal']) }} 怎么在组件中批量给Vuex的getter属性取别名并使用123456789import {mapGetters} from 'vuex'export default{ computed:{ ...mapGetters({ 'myTotal':'total', 'myDiscountTotal':'discountTotal' }) }} 在Vuex的state中有个状态number表示货物数量，在组件怎么改变它。首先要在mutations中注册一个mutation。 12345678910const store = new Vuex.Store({ state: { number: 10, }, mutations: { SET_NUMBER(state,data){ state.number=data; } },}); 在组件中使用this.$store.commit提交mutation，改变number 1this.$store.commit('SET_NUMBER',10) 在Vuex中使用mutation要注意什么。mutation必须是一个同步的函数。 在组件中多次提交同一个mutation，怎么写使用更方便。使用mapMutations辅助函数,在组件中这么使用 123456import { mapMutations } from 'vuex'methods:{ ...mapMutations({ setNumber:'SET_NUMBER', })} 然后调用this.setNumber(10)相当调用this.$store.commit('SET_NUMBER',10) Vuex中action和mutation有什么区别？action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态。 action 可以包含任意异步操作。mutation只能是同步操作。 提交方式不同，action 是用this.$store.dispatch('ACTION_NAME',data)来提交。mutation是用this.$store.commit('SET_NUMBER',10)来提交。 接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了 12345678{ state, // 等同于 `store.state`，若在模块中则为局部状态 rootState, // 等同于 `store.state`，只存在于模块中 commit, // 等同于 `store.commit` dispatch, // 等同于 `store.dispatch` getters, // 等同于 `store.getters` rootGetters // 等同于 `store.getters`，只存在于模块中} Vuex中action和mutation有什么相同点？第二参数都可以接收外部提交时传来的参数。 this.$store.dispatch('ACTION_NAME',data)和this.$store.commit('SET_NUMBER',10) 在组件中多次提交同一个action，怎么写使用更方便。使用mapActions辅助函数,在组件中这么使用 12345methods:{ ...mapActions({ setNumber:'SET_NUMBER', })} 然后调用this.setNumber(10)相当调用this.$store.dispatch('SET_NUMBER',10) Vuex中action通常是异步的，那么如何知道action什么时候结束呢？在action函数中返回Promise，然后再提交时候用then处理 12345678910111213actions:{ SET_NUMBER_A({commit},data){ return new Promise((resolve,reject) =&gt;{ setTimeout(() =&gt;{ commit('SET_NUMBER',10); resolve(); },2000) }) }}this.$store.dispatch('SET_NUMBER_A').then(() =&gt; { // ...}) Vuex中有两个action，分别是actionA和actionB，其内都是异步操作，在actionB要提交actionA，需在actionA处理结束再处理其它操作，怎么实现？利用ES6的async和await来实现。 123456789actions:{ async actionA({commit}){ //... }, async actionB({dispatch}){ await dispatch ('actionA')//等待actionA完成 // ... }} 有用过Vuex模块吗，为什么要使用，怎么使用。有，因为使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。所以将 store 分割成模块（module）。每个模块拥有自己的 state、mutations、actions、getters，甚至是嵌套子模块，从上至下进行同样方式的分割。 在module文件新建moduleA.js和moduleB.js文件。在文件中写入 123456789101112131415161718const state={ //...}const getters={ //...}const mutations={ //...}const actions={ //...}export default{ state, getters, mutations, actions} 然后再index.js引入模块 123456789101112import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);import moduleA from './module/moduleA'import moduleB from './module/moduleB'const store = new Vuex.Store({ modules:{ moduleA, moduleB }})export default store 在模块中，getter和mutation接收的第一个参数state，是全局的还是模块的？第一个参数state是模块的state，也就是局部的state。 在模块中，getter和mutation和action中怎么访问全局的state和getter？在getter中可以通过第三个参数rootState访问到全局的state,可以通过第四个参数rootGetters访问到全局的getter。 在mutation中不可以访问全局的satat和getter，只能访问到局部的state。 在action中第一个参数context中的context.rootState访问到全局的state，context.rootGetters访问到全局的getter。 在组件中怎么访问Vuex模块中的getter和state,怎么提交mutation和action？ 直接通过this.$store.getters和this.$store.state来访问模块中的getter和state。 直接通过this.$store.commit('mutationA',data)提交模块中的mutation。 直接通过this.$store.dispatch('actionA',data)提交模块中的action。 用过Vuex模块的命名空间吗？为什么使用，怎么使用。默认情况下，模块内部的action、mutation和getter是注册在全局命名空间，如果多个模块中action、mutation的命名是一样的，那么提交mutation、action时，将会触发所有模块中命名相同的mutation、action。 这样有太多的耦合，如果要使你的模块具有更高的封装度和复用性，你可以通过添加namespaced: true 的方式使其成为带命名空间的模块。 1234567export default{ namespaced: true, state, getters, mutations, actions} 怎么在带命名空间的模块内提交全局的mutation和action？将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。 12this.$store.dispatch('actionA', null, { root: true })this.$store.commit('mutationA', null, { root: true }) 怎么在带命名空间的模块内注册全局的action？123456actions: { actionA: { root: true, handler (context, data) { ... } } } 组件中怎么提交modules中的带命名空间的moduleA中的mutationA？1this.$store.commit('moduleA/mutationA',data) 怎么使用mapState，mapGetters，mapActions和mapMutations这些函数来绑定带命名空间的模块？首先使用createNamespacedHelpers创建基于某个命名空间辅助函数 123456789101112131415161718import { createNamespacedHelpers } from 'vuex';const { mapState, mapActions } = createNamespacedHelpers('moduleA');export default { computed: { // 在 `module/moduleA` 中查找 ...mapState({ a: state =&gt; state.a, b: state =&gt; state.b }) }, methods: { // 在 `module/moduleA` 中查找 ...mapActions([ 'actionA', 'actionB' ]) }} Vuex插件有用过吗？怎么用简单介绍一下？Vuex插件就是一个函数，它接收 store 作为唯一参数。在Vuex.Store构造器选项plugins引入。 在store/plugin.js文件中写入 123456export default function createPlugin(param){ return store =&gt;{ //... }}复制代码 然后在store/index.js文件中写入 123456import createPlugin from './plugin.js'const myPlugin = createPlugin()const store = new Vuex.Store({ // ... plugins: [myPlugin]}) 在Vuex插件中怎么监听组件中提交mutation和action？ 用Vuex.Store的实例方法subscribe监听组件中提交mutation 用Vuex.Store的实例方法subscribeAction监听组件中提交action 在store/plugin.js文件中写入 12345678910111213141516171819202122export default function createPlugin(param) { return store =&gt; { store.subscribe((mutation, state) =&gt; { console.log(mutation.type)//是那个mutation console.log(mutation.payload) console.log(state) }) // store.subscribeAction((action, state) =&gt; { // console.log(action.type)//是那个action // console.log(action.payload)//提交action的参数 // }) store.subscribeAction({ before: (action, state) =&gt; {//提交action之前 console.log(`before action ${action.type}`) }, after: (action, state) =&gt; {//提交action之后 console.log(`after action ${action.type}`) } }) }}复制代码 然后在store/index.js文件中写入 123456import createPlugin from './plugin.js'const myPlugin = createPlugin()const store = new Vuex.Store({ // ... plugins: [myPlugin]}) 在v-model上怎么用Vuex中state的值？需要通过computed计算属性来转换。 123456789101112&lt;input v-model=&quot;message&quot;&gt;// ...computed: { message: { get () { return this.$store.state.message }, set (value) { this.$store.commit('updateMessage', value) } }} Vuex的严格模式是什么,有什么作用,怎么开启？在严格模式下，无论何时发生了状态变更且不是由 mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 在Vuex.Store 构造器选项中开启,如下 123const store = new Vuex.Store({ strict:true,}) 怎么解决Vuex页面刷新数据丢失问题？ 在app.vue的created方法中读取sessionstorage中的数据存储在store中，此时用vuex.store的 replaceState方法，替换store的根状态 在beforeunload方法中将store.state存储到sessionstorage中。 12345678910111213141516created() { const _self = this const storekey = &quot;STOR_STATE_CACHE&quot; const storeStateCache = sessionStorage.getItem(storekey) if (storeStateCache) { const state = JSON.parse(storeStateCache) this.$store.replaceState(Object.assign({},this.$store.state,state)) sessionStorage.removeItem(storekey) } window.addEventListener(&quot;beforeunload&quot;,function(){ const state = _self.$store.state const stateString = JSON.stringify(state) sessionStorage.setItem(storekey,stateString) })},","link":"/note/2022/07/19/vuex%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"vue的watch、computed的区别","text":"vue的watch、computed的区别dataVue在defineReactive中会为data中的每个属性生成一个dep对象，用于依赖收集。之后通过Object.defineProperty方法重写了data中各个属性的get和set方法，当我们为属性赋值的时候会触发set方法，如果前后两次的值不相同，会触发dep.notify()方法，通知所有依赖的watcher进行update。当Vue实例创建完毕，进行vm.$mount方法后，data中的属性可能会被get，所有被get了的属性会通过dep.depend()方法，将Dep.target上的watcher添加到subs数组中，从而完成依赖收集的流程。 Computed 它支持缓存，只有依赖的数据发生了变化，才会重新计算 不支持异步，当Computed中有异步操作时，无法监听数据的变化 computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。 如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed 如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。 Watch 它不支持缓存，数据变化时，它就会触发相应的操作 支持异步监听 监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值 当一个属性发生变化时，就需要执行相应的操作 监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数： immediate：组件加载立即触发回调函数 deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。 当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。 总结： computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。 watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。 运用场景： 当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。 当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 链接：https://juejin.cn/post/6919373017218809864","link":"/note/2022/04/05/vue%E7%9A%84watch%E3%80%81computed%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"为什么0.1 + 0.2 !&#x3D; 0.3。","text":"为什么0.1 + 0.2 != 0.3。 12let n1 = 0.1, n2 = 0.2console.log(n1 + n2) // 0.30000000000000004 计算机在存储数据时是通过二进制的方式存的，所以计算机在做计算是时，实际上是将数字转化为二进制进行计算的。计算0.1+0.2时，0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数，在相加后得到的二进制结果也是无限循环的二进制数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。 所以，0.1和0.2的二进制数相加再转化为十进制数就是：0.30000000000000004 解决方法：JavaScript中可以使用bignumber.js这个js库解决精度问题。","link":"/note/2022/03/24/%E4%B8%BA%E4%BB%80%E4%B9%880.1%20+%200.2%20!=%200.3/"},{"title":"vue面试题","text":"props、methods、data、computed、watch初始化顺序Vue在初始化事会调用initState方法 12345678910111213141516171819export function initState(vm: Component) { const opts = vm.$options if (opts.props) initProps(vm, opts.props) // Composition API initSetup(vm) // methods-&gt;data-&gt;computed-&gt;watch if (opts.methods) initMethods(vm, opts.methods) if (opts.data) { initData(vm) } else { const ob = observe((vm._data = {})) ob &amp;&amp; ob.vmCount++ } if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) { initWatch(vm, opts.watch) }} 从改方法中可以看出Vue初始化顺序：props-&gt;methods-&gt;data-&gt;computed-&gt;watch Prop允许使用哪些数据类型？String、Number、Boolean、Array、Object、Date、Function、Symbol。 此外还可以是一个自定义的构造函数Personnel，并且通过 instanceof 来验证propwokrer的值是否是通过这个自定义的构造函数创建的。 123456789function Personnel(name,age){ this.name = name; this.age = age;}export default { props:{ wokrer:Personnel }} prop在default和validator函数中能用data和computed的数据吗？不能，因为prop会在一个组件实例创建之前进行验证，所以data和computed在default或validator函数中是不可用的。 computed watch和method区别computed：默认computed也是一个watcher具备缓存，只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。如果一个数据依赖于其他数据，使用 computed watch：每次都需要执行函数。 watch 更适用于数据变化时的异步操作。如果需要在某个数据变化时做一些事情，使用watch。 method：只要把方法用到模板上了,每次一变化就会重新渲染视图，性能开销大 v-if、v-for优先级123456789101112131415161718192021222324252627282930313233343536373839404142export function genElement(el: ASTElement, state: CodegenState): string { if (el.parent) { el.pre = el.pre || el.parent.pre } if (el.staticRoot &amp;&amp; !el.staticProcessed) { return genStatic(el, state) } else if (el.once &amp;&amp; !el.onceProcessed) { return genOnce(el, state) } else if (el.for &amp;&amp; !el.forProcessed) { return genFor(el, state) } else if (el.if &amp;&amp; !el.ifProcessed) { return genIf(el, state) } else if (el.tag === 'template' &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) { return genChildren(el, state) || 'void 0' } else if (el.tag === 'slot') { return genSlot(el, state) } else { // component or element let code if (el.component) { code = genComponent(el.component, el, state) } else { let data if (!el.plain || (el.pre &amp;&amp; state.maybeComponent(el))) { data = genData(el, state) } const children = el.inlineTemplate ? null : genChildren(el, state, true) code = `_c('${el.tag}'${ data ? `,${data}` : '' // data }${ children ? `,${children}` : '' // children })` } // module transforms for (let i = 0; i &lt; state.transforms.length; i++) { code = state.transforms[i](el, code) } return code }} 在源码中发现 先处理静态节点（staticRoot） 然后处理once 最后才会处理for 代码显示for优先于if 断点调试之后也是证实for优先于if 结论： 1、v-for优先于v-if被解析（把你怎么知道的告诉面试官，看过源码） 2、如果同时出现，每次渲染都会先执行循环在判断条件，无论如何循环都不可避免，浪费了性能 3、要避免出现这种情况，在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for循环 KEY在v-for中使用key，会提升性能吗，为什么？ 参考答案 主要看v-for渲染的是什么。 如果渲染是一个简单的列表，如不依赖子组件状态或临时DOM状态(例如：表单输入值)的列表渲染输出,不用key性能会更好，因为不用key采用的是“就地更新”的策略。如果数据项的顺序被改变， Vue将不会移动DOM元素来匹配数据项的顺序，而是就地更新每个元素。 &lt;template&gt; &lt;div&gt; &lt;span v-for=\"item in lists\"&gt;{{item}}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { lists: [1, 2, 3, 4, 5] } }, } &lt;/script&gt; 复制代码 以上的例子，v-for的内容会生成以下的DOM节点数组，我们给每一个节点标记一个身份id，以辨别节点的位置： [ '&lt;span&gt;1&lt;/span&gt;', // id： A '&lt;span&gt;2&lt;/span&gt;', // id: B '&lt;span&gt;3&lt;/span&gt;', // id: C '&lt;span&gt;4&lt;/span&gt;', // id: D '&lt;span&gt;5&lt;/span&gt;' // id: E ] 复制代码 将lists中的数据进行位置调换，变成[2,4,3,1,5]，在没有key的情景下，节点位置不变，但是节点的内容更新了，这就是“就地更新” [ '&lt;span&gt;2&lt;/span&gt;', // id： A '&lt;span&gt;4&lt;/span&gt;', // id: B '&lt;span&gt;3&lt;/span&gt;', // id: C '&lt;span&gt;1&lt;/span&gt;', // id: D '&lt;span&gt;5&lt;/span&gt;' // id: E ] 复制代码 但是在有key的情景下，节点位置进行了交换，但是内容没有更新 [ '&lt;span&gt;2&lt;/span&gt;', // id： B '&lt;span&gt;4&lt;/span&gt;', // id: D '&lt;span&gt;3&lt;/span&gt;', // id: C '&lt;span&gt;1&lt;/span&gt;', // id: A '&lt;span&gt;5&lt;/span&gt;' // id: E ] 复制代码 如果渲染不是一个简单的列表，用key性能会更好一点，因为vue是采用diff算法来对比新旧虚拟节点来更新节点，在diff算法中，当新节点跟旧节点头尾交叉对比没有结果时，先处理旧节点生成一个健为key，值为节点下标index的map映射，如果新节点有key，会通过map映射找到对应的旧节点，如果新节点没有key，会采用遍历查找的方式去找到对应的旧节点，一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。 // vue源码 src/core/vdom/patch.js 488行 // 以下是为了阅读性进行格式化后的代码 // oldCh 是一个旧虚拟节点数组 // oldKeyToIdx map映射对象 // idxInOld 对比后得到旧节点下标 if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) } if (isDef(newStartVnode.key)) { // map 方式获取 idxInOld = oldKeyToIdx[newStartVnode.key] } else { // 遍历方式获取 idxInOld = findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) } 复制代码 创建map函数 function createKeyToOldIdx(children, beginIdx, endIdx) { let i, key const map = {} for (i = beginIdx; i &lt;= endIdx; ++i) { key = children[i].key if (isDef(key)) map[key] = i } return map } 复制代码 遍历寻找函数 // sameVnode 是对比新旧节点是否相同的函数 function findIdxInOld(node, oldCh, start, end) { for (let i = start; i &lt; end; i++) { const c = oldCh[i]; if (isDef(c) &amp;&amp; sameVnode(node, c)) return i } } 复制代码 key除了在v-for中使用，还有什么作用？ 参考答案 还可以强制替换元素/组件而不是重复使用它。在以下场景可以使用 完整地触发组件的生命周期钩子 触发过渡 &lt;transition&gt; &lt;span :key=\"text\"&gt;{{ text }}&lt;/span&gt; &lt;/transition&gt; 复制代码 当 text 发生改变时，&lt;span&gt;会随时被更新，因此会触发过渡。 使用key要什么要注意的吗？ 参考答案 不要使用对象或数组之类的非基本类型值作为key，请用字符串或数值类型的值； 不要使用数组的index作为key值，因为在删除数组某一项，index也会随之变化，导致key变化，渲染会出错。 例：在渲染[a,b,c]用 index 作为 key，那么在删除第二项的时候，index 就会从 0 1 2 变成 0 1（而不是 0 2)，随之第三项的key变成1了，就会误把第三项删除了。 Vue组件之间的通信1.组件间常用方式有以下8种： props $emits/props $children/$parent $attrs/$listeners ref $root eventbus vuex 注意vue3种废弃的几个api $children、$listeners、$eventbus 父子通信：props、$emits、$parent、ref、$attrs 兄弟组件：$parent、$root、eventsbus、vuex 跨层级：eventbus、vuex、provide/inject依赖注入 父子间通信:父亲提供数据通过属性 props传给儿子；儿子通过 $on 绑父亲的事件，再通过 $emit 触发自己的事件（发布订阅） 利用父子关系 $parent 、 $children ， 获取父子组件实例的方法。 父组件提供数据，子组件注入。 provide 、 inject ，插件用得多。 ref 获取组件实例，调用组件的属性、方法 跨组件通信 Event Bus （Vue.prototype.bus=newVue）其实基于on与$emit vuex 状态管理实现通信 Vue父子组件双向绑定的方法有哪些？ 通过自定义事件this.$emit 通过xxx.sync和this.$emit('update:xxx',value) 通过v-model，原理this.$emit('input',value)和v-model Vue生命周期以及每个阶段做的事1.每个Vue组件被创建后都会经过一系列初始化步聚，比如，他需要数据观测，模版编译，挂载实例到dom上，以及数据变化时更新dom。 2.Vue生命周期总共分为8个阶段：创建前后，载入前后，更新前后，销毁前后，以及一些特殊的生命周期。Vue3中新增了3个用于调试和服务端渲染场景。 Vue2 Vue2 描述 结合实践 beforeCreate beforeCreate 组件实例被创建之初，实例初始化之后，数据观测之前调用 通常用于插件开发中执行一些初始化任务 created created 组件实例已经完全创建，实例创建万之后调用。实例完成：数据观测、属性和方法的运算、 watch/event 事件回调。无 $el . 组件初始化完毕，可以访问各种数据，获取接口数据等 beforeMounted beforeMounted 在挂载开始之前被调用：相关的 render 函数首次被调用。在挂载之前调用，相关 render 函数首次被调用 mounted mounted 该钩子在服务器端渲染期间不被调用。组件挂载到实例上去之后，el被新创建的vm.$el替换，并挂载到实例上去之后调用改钩子。 该钩子在服务器端渲染期间不被调用。dom已创建，可用于获取访问数据和dom元素；访问子组件等。 beforeUpdate beforeUpdate 组件数据发生变化，更新之前。数据更新前调用，发生在虚拟DOM重新渲染和打补丁，在这之后会调用改钩子。 此时view层的还未更新，可用于更新前获取各种状态。 updated updated 组件数据更新之后，由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用改钩子。 完成view`层的更新，更新后，所有状态已是最新。 beforeDestroy beforeUnmounted 组件实例销毁之前，实例销毁前调用，实例仍然可用。 实例销毁前调用，可用于一些定时器或订阅的取消。 destroyed unmounted 组件实例销毁之后，实例销毁之后调用，调用后，Vue实例指示的所有东西都会解绑，所有事件监听器和所有子实例都会被移除 销毁一个实例。可清理它与其他实例的连接，解绑它的全部指令及时间监听器 activated activated keep-alive缓存的组件激活时 deactivated deactivated keep-alive缓存的组件停用时调用 errorCaptured errorCaptured 捕获一个来自子孙组件的错误时被调用 – renderTracked 调试钩子，响应式依赖被收集时调用 – renderTriggered 调试钩子，响应式依赖被触发时调用 – serverPrefetch Sir only，组件实例在服务器上被渲染前调用 Vue在created和mounted这两个生命周期中请求有什么区别？在created中，页面视图还没有出现，如何请求过多，页面会长时间处于白屏状态，DOM节点没有出来，无法操作DOM。在mounted不会这样，比较好。 双向绑定使用和原理1.vue中双向绑定是一个指令v-model，可以绑定一个响应式数据到视图，同时视图中变化能改变该值。 2.v-model是语法糖，默认情况下相当于:value和@input。使用v-model可以减少大量繁琐的事件处理代码，提高开发效率。 3.通常在表单项使用v-model，还可以在自定义组件上使用，表示某个值的输入和输出控制。 4.通过&lt;input v-model=&quot;xxx&quot;/&gt;的方式绑定到表单元素value上，对于checkbox，可以使用true-value和false-value指定特殊的值，对于radio可以使用value指定特殊的值；对于select可以通过options元素的value设置特殊的值，还可以结合.lazy，.number，.trim对v-model的行为做进一步的限制；v-model用在自定义组件上时又有很大的不同，vue3中它类似于.sync修饰符，最终展开的结果时modelValue属性和update:modelValue事件；vue3中我们甚至可以用参数形式指定多个不同的绑定，例如：v-model:foo和v-model:bar。 5.我做过测试，输出包含v-model模板的组件渲染函数，发现它会被转换为value属性的绑定以及一个事件监听，事件回调函数中会做相应变量更新操作，这说明神奇魔法实际上是vue的编译器完成的。 Vue中如何扩展一个组件答题思路： 按照逻辑扩展和内容扩展来列举，逻辑扩展有：mixins、extends、composition api；内容扩展有slots； 分别说出他们使用方法、场景差异和问题。 作为扩展，还可以说说vue3中新引入的composition api带来的变化。 常见的组件扩展方法有：mixins，slots，extends等 混入mixins是分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。 插槽主要用于vue组件中的内容分发，也可以用于组件扩展。如果要精确分发到不同位置可以使用具名插槽，如果要使用子组件中的数据可以使用作用域插槽。 组件选项中还有一个不太常用的选项extends，也可以起到扩展组件的目的。 混入的数据和方法不能明确判断来源且可能和当前组件内变量产生命名冲突，vue3中引入的composition api，可以很好解决这些问题，利用独立出来的响应式模块可以很方便的编写独立逻辑并提供响应式的数据，然后在setup选项中有机组合使用。 可能追问： Vue.extend方法你用过吗？它能用来做组件扩展吗？ 子组件可以直接改变父组件的数据么?分析这是一个实践知识点，组件化开发过程中有个单项数据流原则，不在子组件中修改父组件是个常识问题。 参考文档：https://staging.vuejs.org/guide/components/props.html#one-way-data-flow 思路 讲讲单项数据流原则，表明为何不能这么做 举几个常见场景的例子说说解决方案 结合实践讲讲如果需要修改父组件状态应该如何做 回答范例 所有的 prop 都使得其父子之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。另外，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器控制台中发出警告。 const props = defineProps([‘foo’]) // ❌ 下面行为会被警告, props是只读的! props.foo = ‘bar’ 实际开发过程中有两个场景会想要修改一个属性： 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data，并将这个 prop 用作其初始值： const props = defineProps([‘initialCounter’]) const counter = ref(props.initialCounter) 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性： const props = defineProps([‘size’]) // prop变化，计算属性自动更新 const normalizedSize = computed(() =&gt; props.size.trim().toLowerCase()) 实践中如果确实想要改变父组件属性应该emit一个事件让父组件去做这个变更。注意虽然我们不能直接修改一个传入的对象或者数组类型的prop，但是我们还是能够直接改内嵌的对象或属性。 Vue要做权限管理该怎么做？控制到按钮级别的权限怎么做？分析综合实践题目，实际开发中经常需要面临权限管理的需求，考查实际应用能力。 权限管理一般需求是两个：页面权限和按钮权限，从这两个方面论述即可。 思路 权限管理需求分析：页面和按钮权限 权限管理的实现方案：分后端方案和前端方案阐述 说说各自的优缺点 回答范例 权限管理一般需求是页面权限和按钮权限的管理 具体实现的时候分后端和前端两种方案： 前端方案会把所有路由信息在前端配置，通过路由守卫要求用户登录，用户登录后根据角色过滤出路由表。比如我会配置一个asyncRoutes数组，需要认证的页面在其路由的meta中添加一个roles字段，等获取用户角色之后取两者的交集，若结果不为空则说明可以访问。此过滤过程结束，剩下的路由就是该用户能访问的页面，最后通过router.addRoutes(accessRoutes)方式动态添加路由即可。 后端方案会把所有页面路由信息存在数据库中，用户登录的时候根据其角色查询得到其能访问的所有页面路由信息返回给前端，前端再通过addRoutes动态添加路由信息 按钮权限的控制通常会实现一个指令，例如v-permission，将按钮要求角色通过值传给v-permission指令，在指令的moutned钩子中可以判断当前用户角色和按钮是否存在交集，有则保留按钮，无则移除按钮。 纯前端方案的优点是实现简单，不需要额外权限管理页面，但是维护起来问题比较大，有新的页面和角色需求就要修改前端代码重新打包部署；服务端方案就不存在这个问题，通过专门的角色和权限管理页面，配置页面和按钮权限信息到数据库，应用每次登陆时获取的都是最新的路由信息，可谓一劳永逸！ 知其所以然路由守卫 https://github1s.com/PanJiaChen/vue-element-admin/blob/HEAD/src/permission.js#L13-L14 路由生成 https://github1s.com/PanJiaChen/vue-element-admin/blob/HEAD/src/store/modules/permission.js#L50-L51 动态追加路由 https://github1s.com/PanJiaChen/vue-element-admin/blob/HEAD/src/permission.js#L43-L44 可能的追问 类似Tabs这类组件能不能使用v-permission指令实现按钮权限控制？ 1234&lt;el-tabs&gt; &lt;el-tab-pane label=&quot;⽤户管理&quot; name=&quot;first&quot;&gt;⽤户管理&lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;⻆⾊管理&quot; name=&quot;third&quot;&gt;⻆⾊管理&lt;/el-tab-pane&gt;&lt;/el-tabs&gt; 服务端返回的路由信息如何添加到路由器中？ 12345678910111213141516171819// 前端组件名和组件映射表const map = { //xx: require('@/views/xx.vue').default // 同步的⽅式 xx: () =&gt; import('@/views/xx.vue') // 异步的⽅式}// 服务端返回的asyncRoutesconst asyncRoutes = [ { path: '/xx', component: 'xx',... }]// 遍历asyncRoutes，将component替换为map[component]function mapComponent(asyncRoutes) { asyncRoutes.forEach(route =&gt; { route.component = map[route.component]; if(route.children) { route.children.map(child =&gt; mapComponent(child)) } })}mapComponent(asyncRoutes) vue响应式理解思路 什么是响应式？ 所谓数据响应式就是能够使数据发生变化可以被检测并对这种变化做出响应式的机制。 为什么vue需要响应式？ MVVM框架中要解决的一个核心问题就是连接数据层和视图层，通过数据驱动应用，数据变化，视图更新，要做到这点就需要对数据做响应式处理，这样一旦数据发生了变化就可以立即做出更新处理。 它能给我们带来什么好处？ 以vue为例说明，通过数据响应式加上虚拟DOM和patch算法，开发人员只需要操作数据，关心业务，完全不用接触频繁的DOM操作，从而大大提升开发效率，降低开发难度。 vue的响应式是怎么实现的？有哪些优缺点？ vue2中数据响应式会根据数据类型来做不同的处理，如果是对象则采用Object.defineProperty()的方式定义数据拦截，当数据被访问或发生变化时，我们感知并做出响应；如果是数组则通过覆盖数组对象原型的7个数组变更方法，使这些方法可以做额外的更新通知，从而做出响应。这种机制很好的解决了数据响应化的问题，但在实际使用中也存在一些缺点：比如初始化时需要递归遍历整个数据造成的性能损失；新增或删除属性时需要用户使用Vue.set/delete这样特殊的api才生效；对于es6中新产生的Map、Set这些数据结构不支持等问题。 vue3中的响应式的新变化 为了解决这些问题，vue3重新编写了这一部分的实现：利用ES6点Proxy代理要响应化的数据，它有很多好处，编程体验是一致的，不需要使用特殊的api，初始化和内存消耗都得到了大幅改善；另外由于响应化的实现代码抽取为独立的reactivity包，使我们可以更灵活的shying它，第三方的扩展开发起来更加灵活，缺点就是在兼容性上没有Object.defineProperty高，在一些考虑老设备的开发上需要关注这方面。 相关源码vue2 https://github1s.com/vuejs/vue/blob/HEAD/src/core/observer/index.ts#L135-L136 vue3 https://github1s.com/vuejs/core/blob/HEAD/packages/reactivity/src/reactive.ts#L89-L90 https://github1s.com/vuejs/core/blob/HEAD/packages/reactivity/src/ref.ts#L67-L68 vue是如何实现响应式数据的？Vue2：Object.defineProperty重新定义了data中的所的属性，Object.defineProperty可以是数据在设置和读取是增加一个拦截功能，拦截属性的获取，进行依赖收集。拦截属性的更新操作，当属性值发生改变时，就会触发dep的notify方法，数据更新通知watcher执行update 。 具体的过程：首先Vue使用 initData 初始化用户传入的参数，然后使用 new Observer 对数据进行观测，如果数据是一个对象类型就会调用 this.walk（value） 对对象进行处理，内部使用 defineeReactive 循环对象属性定义响应式变化，核心就是使用 Object.defineProperty 重新定义数据。 vue中是如何检测数组的变化的。数组就是使用 object.defineProperty 重新定义数组的每一项，那能引起数组变化的方法我们都是知道的， pop 、 push 、 shift 、 unshift 、 splice 、 sort 、 reverse 这七种，只要这些方法执行改了数组内容，我就更新内容就好了，是不是很好理解。 是用来函数劫持的方式，重写了数组方法，具体呢就是更改了数组的原型，更改成自己的，用户调数组的一些方法的时候，走的就是自己的方法，然后通知视图去更新。 数组里每一项可能是对象，那么我就是会对数组的每一项进行观测，（且只有数组里的对象才能进行观测，观测过的也不会进行观测） vue3：改用 proxy ，可直接监听对象数组的变化。 vue中的事件绑定原理 原生 DOM 的绑定：Vue在创建真实DOM时会调用 createElm ，默认会调用 invokeCreateHooks 。会遍历当前平台下相对的属性处理代码，其中就有 updateDOMListeners 方法，内部会传入 add（） 方法 组件绑定事件，原生事件，自定义事件；组件绑定之间是通过Vue中自定义的 $on 方法实现的。 （可以理解为：组件的 nativeOnOn 等价于 普通元素on 组件的on会单独处理） v-model中的实现原理及如何自定义v-modelv-model 可以看成是 value+input 方法的语法糖（组件）。原生的 v-model ，会根据标签的不同生成不同的事件与属性。解析一个指令来。 自定义：自己写 model 属性，里面放上 prop 和 event 为什么Vue采用异步渲染呢？Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能， Vue 会在本轮数据更新后，在异步更新视图。核心思想 nextTick 。 dep.notify（） 通知 watcher进行更新， subs[i].update 依次调用 watcher 的 update ， queueWatcher 将watcher 去重放入队列， nextTick（ flushSchedulerQueue ）在下一tick中刷新watcher队列（异步）。 🌸接着追问，要是你nextTick都能讲得很清楚的话那基本你是明白了。 了解nextTick吗？异步方法，异步渲染最后一步，与JS事件循环联系紧密。主要使用了宏任务微任务（setTimeout、promise那些），定义了一个异步方法，多次调用nextTick会将方法存入队列，通过异步方法清空当前队列。 父子组件生命周期调用顺序渲染顺序：先父后子，完成顺序：先子后父 12345678graph LRA[parent_befroeCreate] --&gt; B(parent_beforeCreated)B --&gt; C(component_beforeCreate)C --&gt; D(component_created)D --&gt; E(component_beforeMount)E --&gt; G(component_mounted)G --&gt; H(parent_beforeMount)H --&gt; J(parent_mounted) 更新顺序：父更新导致子更新，子更新完成后父 12345graph LRA[parent beforeUpdate] --&gt; B(component beforeUpdate)B --&gt; C(component updated)C --&gt; D(parent updated) 销毁顺序：先父后子，完成顺序：先子后父 1234graph LRA[parent beforeDestroy] --&gt; B(component beforeDestroy)B --&gt; C(component destroyed)C --&gt; D(parent destroyed) diff算法时间复杂度： 个树的完全 diff 算法是一个时间复杂度为 O(n*3） ，vue进行优化转化成 O(n) 。 理解： 最小量更新， key 很重要。这个可以是这个节点的唯一标识，告诉 diff 算法，在更改前后它们是同一个DOM节点 扩展 v-for 为什么要有 key ，没有 key 会暴力复用，举例子的话随便说一个比如移动节点或者增加节点（修改DOM），加 key 只会移动减少操作DOM。 只有是同一个虚拟节点才会进行精细化比较，否则就是暴力删除旧的，插入新的。 只进行同层比较，不会进行跨层比较。 diff算法的优化策略：四种命中查找，四个指针 旧前与新前（先比开头，后插入和删除节点的这种情况） 旧后与新后（比结尾，前插入或删除的情况） 旧前与新后（头与尾比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧后之后） 旧后与新前（尾与头比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧前之前） v-for和v-if为什么不能连用v-for会比v-if的优先级更高，连用的话会把每一个元素都添加上v-if，造成性能问题。 v-html会导致的问题 XSS攻击 v-html会替换标签内的元素 组件渲染和更新过程渲染组件时，会通过 vue.extend() 方法构建子组件的构造函数，并进行实例化。最终手动调用 $mount() 进行挂载。更新组件时会进行 patchVnode 流程，核心就是 diff 算法。 组件中的data为什么是函数new Vue是一个单例模式，不会有任何的合并操作，所以根实例不必校验data一定是一个函数。 组件的data必须是一个函数，是为了防止两个组件的数据产生污染。 如果都是对象的话，会在合并的时候，指向同一个地址。 而如果是函数的时候，合并的时候调用，会产生两个空间。 为什么要使用异步组件？答案 节省打包出的结果，异步组件分开打包，采用jsonp的方式进行加载，有效解决文件过大的问题。 核心就是包组件定义变成一个函数，依赖 import（） 语法，可以实现文件的分割加载。 详细的看官方文档：cn.vuejs.org/v2/guide/co… action 与 mutation 的区别答案 mutation 是同步更新， $watch 严格模式下会报错 action 是异步操作，可以获取数据后调用 mutation 提交最终数据 插槽与作用域插槽的区别插槽答案 创建组件虚拟节点时，会将组件儿子的虚拟节点保存起来。当初始化组件时，通过插槽属性将儿子进行分类 {a:[vnode],b[vnode]} 渲染组件时会拿对应的 slot 属性的节点进行替换操作。（插槽的作用域为父组件） 作用域插槽答案 作用域插槽在解析的时候不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此函数进行渲染。 普通插槽渲染的作用域是父组件，作用域插槽的渲染作用域是当前子组件。 vue中相同逻辑如何抽离答案 其实就是考察 vue.mixin 用法，给组件每个生命周期，函数都混入一些公共逻辑。 谈谈对keep-alive的了解答案 keep-alive 可以实现组件的缓存，当组件切换时不会对当前组件进行卸载。常用的2个属性 include/exclude ，2个生命周期 activated ， deactivated # 组件的name选项有什么用？ 递归组件时，组件条用自身使用。 用is特殊用和component内置组件标签时使用。 keep-alive内置组件标签中include 和exclude属性中使用。 递归组件递归引用可以理解为组件调用自身，在开发多级菜单组件时就会用到，调用前要先设置组件的name选项， 注意一定要配合v-if使用，避免形成死循环，用element-vue组件库中NavMenu导航菜单组件开发多级菜单。 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;el-submenu :index=&quot;menu.id&quot; popper-class=&quot;layout-sider-submenu&quot; :key=&quot;menu.id&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;Icon :type=&quot;menu.icon&quot; v-if=&quot;menu.icon&quot;/&gt; &lt;span&gt;{{menu.title}}&lt;/span&gt; &lt;/template&gt; &lt;template v-for=&quot;(child,i) in menu.menus&quot;&gt; &lt;side-menu-item v-if=&quot;Array.isArray(child.menus) &amp;&amp; child.menus.length&quot; :menu=&quot;child&quot;&gt;&lt;/side-menu-item&gt; &lt;el-menu-item :index=&quot;child.id&quot; :key=&quot;child.id&quot; v-else&gt; &lt;Icon :type=&quot;child.icon&quot; v-if=&quot;child.icon&quot;/&gt; &lt;span&gt;{{child.title}}&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/template&gt; &lt;/el-submenu&gt;&lt;/template&gt;&lt;script&gt; export default{ name: 'sideMenuItem', props: { menu: { type: Object, default(){ return {}; } } } }&lt;/script&gt; Vue性能优化回答规范住所从Vue代码编写层说一些优化手段，例如：代码分割、服务器渲染、组件缓存、长列表优化等。 常见的路由懒加载：有效拆分App尺寸、访问时才异步加载 123456const router = createRouter({ routes:[ // 借助webpack的import()实现异步组件 { path:'/foo', component: () =&gt; import('./Foo.vue') } ]}) keep-alive缓存页面：避免重复创建组件实例，且能保留缓存组件状态 12345&lt;router-view v-slot=&quot;{ Component }&quot;&gt; &lt;keep-alive&gt; &lt;component :is=&quot;Component&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/router-view&gt; 使用v-show复用DOM：避免重复创建组件 1234567891011&lt;template&gt; &lt;div class=&quot;cell&quot;&gt; &lt;!-- 这种情况用v-show复用DOM，比v-if效果好 --&gt; &lt;div v-show=&quot;value&quot; class=&quot;on&quot;&gt; &lt;Heavy :n=&quot;10000&quot;/&gt; &lt;/div&gt; &lt;section v-show=&quot;!value&quot; class=&quot;off&quot;&gt; &lt;Heavy :n=&quot;10000&quot;/&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt; v-for遍历避免同时使用v-if：实际上在Vue3中已经是个错误写法 123456789101112131415161718192021&lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;user in activeUsers&quot; &lt;!-- 避免同时使用，vue3中会报错 --&gt; &lt;!-- v-if = &quot;user.isActive&quot; --&gt; :key=&quot;user.id&quot; &gt; {{ user.name }} &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt; export default{ computed:{ activeUsers:function(){ return this.users.filter(user=&gt;isActive) } } }&lt;/script&gt; v-once和v-memo：不再变化的数据使用v-onec，按条件跳过更新是使用v-memo 12345678910111213&lt;!-- 单个元素 --&gt;&lt;span v-once&gt;This will never change: {{msg}}&lt;/span&gt;&lt;!-- 有子元素 --&gt;&lt;div v-once&gt; &lt;h1&gt;comment&lt;/h1&gt; &lt;p&gt;{{msg}}&lt;/p&gt;&lt;/div&gt;&lt;!-- 组件 --&gt;&lt;my-component v-once :comment=&quot;msg&quot;&gt;&lt;/my-component&gt;&lt;!-- `v-for` 指令--&gt;&lt;ul&gt; &lt;li v-for=&quot;i in list&quot; v-once&gt;{{i}}&lt;/li&gt;&lt;/ul&gt; 123&lt;div v-for=&quot;item in list&quot; :key=&quot;item.id&quot; v-memo=&quot;[item.id === selected]&quot;&gt; .......&lt;/div&gt; 长列表性能优化：如果是大数据长列表，可以采用虚拟滚动，只渲染少部分区域的内容 123456789101112&lt;recycle-scroller class=&quot;items&quot; :items=&quot;items&quot; :item-size=&quot;24&quot; &gt; &lt;template v-slot=&quot;{item}&quot;&gt; &lt;FetchItemView :item=&quot;item&quot; @vote=&quot;voteItem(item)&quot; &gt;&lt;/FetchItemView&gt; &lt;/template&gt;&lt;/recycle-scroller&gt; 一些开源库 Vue-virtual-scroller Vue-virtual-scroll-grid 事件销毁：Vue组件销毁时，会自动解绑他的全部指令及事件监听器，但是仅限于组件本身的事件。 12345678export default { created(){ this.timer = setInterval(this.refresh, 2000) }, beforeUnmount(){ clearInterval(this.timer) }} 图片懒加载 对于图片过多，为了加快页面记载速度，所以我们需要将页面内未出现在可视区域内的图片先不做加载，等到滚动到可视区域后在去做加载。 1&lt;img v-lazy=&quot;/static/img/xx.png&quot;/&gt; 参考项目：vue-lazyload 第三方插件按需加载 像element-plus这样的第三方组件库可以按需引入避免体积太大。 1234import { createApp } from &quot;vue&quot;import { Button, Select } from &quot;element-plus&quot;const app = createApp()app.use(Button, Select) 子组件的分割策略：较重的状态组件适合拆分 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;ChildComp/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { components:{ ChildComp:{ methods:{ heavy(){ /* 耗时认为 */ } }， render(h){ return h(&quot;div&quot;,this.heavy()) } } } }&lt;/script&gt; 服务端渲染/静态网站生成：SSR/SSG 如何SPA应用有首屏渲染问题，可以考虑SSR、SSG访问优化。 答案 编码优化： 事件代理 keep-alive 拆分组件 key 保证唯一性 路由懒加载、异步组件 防抖节流 Vue加载性能优化 第三方模块按需导入（ babel-plugin-component ） 图片懒加载 用户体验 app-skeleton 骨架屏 shellap p壳 pwa SEO优化 预渲染 # 页面刷新后vuex的state数据丢失怎么解决？ vuex只是在内存保存状态，刷新之后就会丢失，如果要持久化就要存起来。 localStorage就很合适，提交mutation的时候同时存入localStorage，store中把值取出作为state的初始值即可。 这里有两个问题，不是所有状态都需要持久化；如果需要保存的状态很多，编写的代码就不够优雅，每个提交的地方都要单独做保存处理。这里就可以利用vuex提供的subscribe方法做一个统一的处理。甚至可以封装一个vuex插件以便复用。 类似的插件有vuex-persist、vuex-persistedstate，内部的实现就是通过订阅mutation变化做统一处理，通过插件的选项控制哪些需要持久化 Vue3有哪些改变https://juejin.cn/post/7035805730372321294 Vue.usehttps://juejin.cn/post/6859944479223185416 安装Vue插件。如果插件是个对象，则必须暴露一个install方法，如何是一个方法，则将该方法视为install方法使用。 该 install 方法将以应用实例作为第一个参数被调用。传给 use 的其他 options 参数将作为后续参数传入该安装方法。 当在同一个插件上多次调用此方法时，该插件将仅安装一次。 12345678910111213141516171819// 对象方式export default const MyPlugin = { install(vm, options){ ........ }}// 方法export default function MyPlugin(vm, options){ ........}// --------------------------------------------import { createApp } from 'vue'import MyPlugin from './plugins/MyPlugin'const app = createApp({})app.use(MyPlugin)app.mount('#app') Vue中有哪些指令https://cn.vuejs.org/v2/api/#%E6%8C%87%E4%BB%A4 Vue.directive钩子函数的参数Vue2版本el：指令所绑定的元素，可以用来直接操作 DOM。 binding：一个对象，包含以下 property： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 1234567891011121314151617181920Vue.directive('demo', { bind: function (el, binding, vnode, oldVNode) { var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '&lt;br&gt;' + 'value: ' + s(binding.value) + '&lt;br&gt;' + 'expression: ' + s(binding.expression) + '&lt;br&gt;' + 'argument: ' + s(binding.arg) + '&lt;br&gt;' + 'modifiers: ' + s(binding.modifiers) + '&lt;br&gt;' + 'vnode keys: ' + Object.keys(vnode).join(', ') }, // 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 inserted(el){}, //所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 update(){}, //指令所在组件的 VNode 及其子 VNode 全部更新后调用。 componentUpdated(){}, //只调用一次，指令与元素解绑时调用。 unbind(){}}) Vue3版本el：指令绑定到的元素。这可用于直接操作 DOM。 binding：包含以下 property 的对象。 instance：使用指令的组件实例。 value：传递给指令的值。例如，在 v-my-directive=&quot;1 + 1&quot; 中，该值为 2。 oldValue：先前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否有更改都可用。 arg：传递给指令的参数(如果有的话)。例如在 v-my-directive:foo 中，arg 为 &quot;foo&quot;。 modifiers：包含修饰符(如果有的话) 的对象。例如在 v-my-directive.foo.bar 中，修饰符对象为 {foo: true，bar: true}。 dir：一个对象，在注册指令时作为参数传递。例如，在以下指令中 vnode：一个真实 DOM 元素的蓝图，对应上面收到的 el 参数。 prevNode：上一个虚拟节点，仅在 beforeUpdate 和 updated 钩子中可用。 1234567891011121314151617181920212223242526272829import { createApp } from 'vue'const app = createApp({})// 注册app.directive('my-directive', { // 指令具有一组生命周期钩子： // 在绑定元素的 attribute 或事件监听器被应用之前调用 created(el, binding, vnode , preVNode) {}, // 在绑定元素的父组件挂载之前调用 beforeMount(el, binding, vnode , preVNode) {}, // 在绑定元素的父组件挂载之后调用 mounted(el, binding, vnode , preVNode) {}, // 在包含组件的 VNode 更新之前调用 beforeUpdate(el, binding, vnode , preVNode) {}, // 在包含组件的 VNode 及其子组件的 VNode 更新之后调用 updated(el, binding, vnode , preVNode) {}, // 在绑定元素的父组件卸载之前调用 beforeUnmount(el, binding, vnode , preVNode) {}, // 在绑定元素的父组件卸载之后调用 unmounted(el, binding, vnode , preVNode) {}})// 注册 (函数指令)app.directive('my-directive', () =&gt; { // 这将被作为 `mounted` 和 `updated` 调用})// getter, 如果已注册，则返回指令定义const myDirective = app.directive('my-directive') Vue组件开发基础全面详解https://juejin.cn/post/6844903890635194376#heading-23 $attrs和$listeners的使用场景？ $attrs：包含父作用域中不作为prop被识别的特性绑定（class和style除外）。在创建基础组件时候经常使用，可以和组件选项inheritAttrs:false和配合使用在组件内部标签上用v-bind=&quot;$attrs&quot;将非prop特性绑定上去； $listeners: 包含了父作用域中（组件标签）的 (不含.native) v-on 事件监听器。 在组件上监听一些特定的事件，比如focus事件时，如果组件的根元素不是表单元素的，则监听不到，那么可以用v-on=&quot;$listeners&quot;绑定到表单元素标签上解决。 EventBus注册在全局上时，路由切换时会重复触发事件，如何解决？在有使用$on的组件中要在beforeDestroy钩子函数中用$off销毁。 Vue组件里写的原生addEventListeners监听事件，要手动去销毁吗？为什么？要，不然会造成多次绑定和内存泄露。关于移除事件监听的坑。 Vue组件里的定时器要怎么销毁？ 如果页面上有很多定时器，可以在data选项中创建一个对象timer，给每个定时器取个名字一一映射在对象timer中， 在beforeDestroy构造函数中for(let k in this.timer){clearInterval(k)}； 如果页面只有单个定时器，可以这么做。 1234const timer = setInterval(() =&gt;{}, 500);this.$once('hook:beforeDestroy', () =&gt; { clearInterval(timer);}) Vue中能监听到数组变化的方法有哪些？为什么这些方法能监听到呢？ push()、pop()、shift()、unshift()、splice()、sort()、reverse()，这些方法在Vue中被重新定义了，故可以监听到数组变化； filter()、concat()、slice()，这些方法会返回一个新数组，也可以监听到数组的变化。 在Vue中那些数组变化无法监听，为什么，怎么解决？参考答案 利用索引直接设置一个数组项时； 修改数组的长度时。 第一个情况，利用已有索引直接设置一个数组项时Object.defineProperty()是可以监听到，利用不存在的索引直接设置一个数组项时Object.defineProperty()是不可以监听到，但是官方给出的解释是由于JavaScript的限制，Vue不能检测以上数组的变动，其实根本原因是性能问题，性能代价和获得的用户体验收益不成正比。 第二个情况，原因是Object.defineProperty()不能监听到数组的length属性。 用this.$set(this.items, indexOfItem, newValue)或this.items.splice(indexOfItem, 1, newValue)来解决第一种情况； 用this.items.splice(newLength)来解决第二种情况。 在Vue中那些对象变化无法监听，为什么，怎么解决？ 对象属性的添加 对象属性的删除 因为Vue是通过Object.defineProperty来将对象的key转成getter/setter的形式来追踪变化，但getter/setter只能追踪一个数据是否被修改，无法追踪新增属性和删除属性，所以才会导致上面对象变化无法监听。 用this.$set(this.obj,&quot;key&quot;,&quot;newValue&quot;)来解决第一种情况； 用Object.assign来解决第二种情况。 删除对象用delete和Vue.delete有什么区别？ delete：只是被删除对象成员变为' '或undefined，其他元素键值不变； Vue.delete：直接删了对象成员，如果对象是响应式的，确保删除能触发更新视图，这个方法主要用于避开 Vue 不能检测到属性被删除的限制。 Vue怎么定义全局方法 挂载到Vue的prototype上。 利用全局Vue.mixin。 用this.$root.$on绑定方法，用this.$root.$off解绑方法，用this.$root.$emit全局调用。 说说你对DOM选项el、template、render的理解？el：提供一个在页面上已存在的DOM元素作为Vue实例的挂载目标。可以是CSS选择器，也可以是一个HTMLElement实例。 因为所有的挂载元素会被Vue生成的DOM替换。因此不推荐挂载Vue实例到html或者body上。 如果在const vm = new Vue({})中存在这个选项，实例将立即进入编译过程，否则，需要显式调用vm.$mount()手动开启编译。 template：一个字符串模板作为Vue实例的标识使用。如果el存在，模板将会替换挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。 如果值以 # 开始，则它将被用作选择符，并使用匹配元素的 innerHTML 作为模板。 render :Vue 选项中的 render 函数若存在，则 Vue 构造函数不会从 template 选项或通过 el 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。 Vue变量名如果以_、$开头的属性会发生什么问题？怎么访问到它们的值？以 _ 或 $ 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突，你可以使用例如 vm.$data._property 的方式访问这些属性。 怎么捕获Vue组件的错误信息？errorCaptured是组件内部钩子，当捕获一个来自子孙组件的错误时被调用，接收error、vm、info三个参数，return false后可以阻止错误继续向上抛出。 errorHandler为全局钩子，使用Vue.config.errorHandler配置，接收参数与errorCaptured一致，2.6后可捕捉v-on与promise链的错误，可用于统一错误处理与错误兜底。 Vue.observable的了解让一个对象可响应。可以作为最小化的跨组件状态存储器。","link":"/note/2022/06/20/vue%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"前端面试题--基础","text":"Map和Set的区别，Map和Object的区别Map和Set的区别 Map是键值对，Set是值的集合，当然键和值可以是任何的值； Map可以通过get方法获取值，而set不能因为它只有值； 都能通过迭代器进行for…of遍历； Set的值是唯一的可以做数组去重，Map由于没有格式限制，可以做数据存储 map和set都是stl中的关联容器，map以键值对的形式存储，key=value组成pair，是一组映射关系。set只有值，可以认为只有一个数据，并且set中元素不可以重复且自动排序。 Objects 和 maps 的比较Object 和 Map 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Map 使用。 不过 Map 和 Object 有一些重要的区别，在下列情况中使用 Map 会是更好的选择： Map Object 意外的键 Map 默认情况不包含任何键。只包含显式插入的键。 一个 Object 有一个原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。备注：虽然从 ES5 开始可以用 Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。 键的类型 一个 Map 的键可以是任意值，包括函数、对象或任意基本类型。 一个 Object 的键必须是一个 String 或是 Symbol。 键的顺序 Map 中的键是有序的。因此，当迭代的时候，一个 Map 对象以插入的顺序返回键值。 虽然 Object 的键目前是有序的，但并不总是这样，而且这个顺序是复杂的。因此，最好不要依赖属性的顺序。自 ECMAScript 2015 规范以来，对象的属性被定义为是有序的；ECMAScript 2020 则额外定义了继承属性的顺序。参见 OrdinaryOwnPropertyKeys 和 EnumerateObjectProperties 抽象规范说明。但是，请注意没有可以迭代对象所有属性的机制，每一种机制只包含了属性的不同子集。（for-in 仅包含了以字符串为键的属性；Object.keys 仅包含了对象自身的、可枚举的、以字符串为键的属性；Object.getOwnPropertyNames 包含了所有以字符串为键的属性，即使是不可枚举的；Object.getOwnPropertySymbols 与前者类似，但其包含的是以 Symbol 为键的属性，等等。） Size Map 的键值对个数可以轻易地通过 size 属性获取。 Object 的键值对个数只能手动计算. 迭代 Map 是 可迭代的 的，所以可以直接被迭代。 Object 没有实现 迭代协议，所以使用 JavaSctipt 的 for…of 表达式并不能直接迭代对象。备注：对象可以实现迭代协议，或者你可以使用 Object.keys 或 Object.entries。for…in 表达式允许你迭代一个对象的可枚举属性。 性能 在频繁增删键值对的场景下表现更好。 在频繁添加和删除键值对的场景下未作出优化。 序列化和解析 没有元素的序列化和解析的支持。（但是你可以使用携带 replacer 参数的 JSON.stringify() 创建一个自己的对 Map 的序列化和解析支持。参见 Stack Overflow 上的提问：How do you JSON.stringify an ES6 Map?） 原生的由 Object 到 JSON 的序列化支持，使用 JSON.stringify()。原生的由 JSON 到 Object 的解析支持，使用 JSON.parse()。 数组的filter、every、flat的作用filter1var newArray = arr.filter(callback(element[, index[, array]])[, thisArg]) 参数 callback 用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。它接受以下三个参数：element数组中当前正在处理的元素。index可选正在处理的元素在数组中的索引。array可选调用了 filter 的数组本身。 thisArg可选 执行 callback 时，用于 this 的值。 返回值一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。 描述filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或等价于 true 的值的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。 callback 被调用时传入三个参数： 元素的值 元素的索引 被遍历的数组本身 如果为 filter 提供一个 thisArg 参数，则它会被作为 callback 被调用时的 this 值。否则，callback 的 this 值在非严格模式下将是全局对象，严格模式下为 undefined。callback 函数最终观察到的 this 值是根据通常函数所看到的 “this”的规则确定的。 filter 不会改变原数组，它返回过滤后的新数组。 filter 遍历的元素范围在第一次调用 callback 之前就已经确定了。在调用 filter 之后被添加到数组中的元素不会被 filter 遍历到。如果已经存在的元素被改变了，则他们传入 callback 的值是 filter 遍历到它们那一刻的值。被删除或从来未被赋值的元素不会被遍历到。 every1arr.every(callback(element[, index[, array]])[, thisArg]) 参数 callback 用来测试每个元素的函数，它可以接收三个参数：element用于测试的当前值。index可选用于测试的当前值的索引。array可选调用 every 的当前数组。 thisArg 执行 callback 时使用的 this 值。 返回值如果回调函数的每一次返回都为 truthy 值，返回 true，否则返回 false。 描述every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个会使 callback 返回 falsy 的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从未被赋值的索引调用。 callback 在被调用时可传入三个参数：元素值，元素的索引，原数组。 如果为 every 提供一个 thisArg 参数，则该参数为调用 callback 时的 this 值。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。详见 this 条目。 every 不会改变原数组。 every 遍历的元素范围在第一次调用 callback 之前就已确定了。在调用 every 之后添加到数组中的元素不会被 callback 访问到。如果数组中存在的元素被更改，则他们传入 callback 的值是 every 访问到他们那一刻的值。那些被删除的元素或从来未被赋值的元素将不会被访问到。 every 和数学中的”所有”类似，当所有的元素都符合条件才会返回 true。正因如此，若传入一个空数组，无论如何都会返回 true。（这种情况属于无条件正确：正因为一个空集合没有元素，所以它其中的所有元素都符合给定的条件。) flat1var newArray = arr.flat([depth]) 主要用于扁平化多维数组，flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 ES6十大特性 Default Parameters（默认参数） in ES6 Template Literals （模板文本）in ES6 Multi-line Strings （多行字符串）in ES6 Destructuring Assignment （解构赋值）in ES6 Enhanced Object Literals （增强的对象文本）in ES6 Arrow Functions （箭头函数）in ES6 Promises in ES6 Block-Scoped Constructs Let and Const（块作用域构造 let 、 const） Classes（类） in ES6 Modules（模块） in ES6 PromisePromise/A+ 规范Promise规范有很多，如Promise/A，Promise/B，Promise/D 以及 Promise/A 的升级版Promise/A+，因为ES6主要用的是Promise/A+规范，该规范内容也比较多，我们挑几个简单的说明下: Promise本身是一个状态机，每一个Promise实例只能有三个状态，pending、fulfilled、reject，状态之间的转化只能是pending-&gt;fulfilled、pending-&gt;reject，状态变化不可逆。 Promise有一个then方法，该方法可以被调用多次，并且返回一个Promise对象（返回新的Promise还是老的Promise对象，规范没有提）。 支持链式调用。 内部保存有一个value值，用来保存上次执行的结果值，如果报错，则保存的是异常信息。 Promise的all和race有什么区别Promise.allPromise.all() 方法接收一个 promise 的 iterable 类型（注：Array，Map，Set 都属于 ES6 的 iterable 类型）的输入，并且只返回一个Promise实例， 那个输入的所有 promise 的 resolve 回调的结果是一个数组。这个Promise的 resolve 回调执行是在所有输入的 promise 的 resolve 回调都结束，或者输入的 iterable 里没有 promise 了的时候。它的 reject 回调执行是，只要任何一个输入的 promise 的 reject 回调执行或者输入不合法的 promise 就会立即抛出错误，并且 reject 的是第一个抛出的错误信息。 完成（Fulfillment）：如果传入的可迭代对象为空，Promise.all 会同步地返回一个已完成（resolved）状态的promise。如果所有传入的 promise 都变为完成状态，或者传入的可迭代对象内没有 promise，Promise.all 返回的 promise 异步地变为完成。在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组，它包含所有的传入迭代参数对象的值（也包括非 promise 值）。 失败/拒绝（Rejection）：如果传入的 promise 中有一个失败（rejected），Promise.all 异步地将失败的那个结果给失败状态的回调函数，而不管其它 promise 是否完成。 Promise.racePromise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。 描述race 函数返回一个 Promise，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。 如果传的迭代是空的，则返回的 promise 将永远等待。 如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值。 var、let、const区别varvar 语句 用于声明一个函数范围或全局范围的变量，并可将其初始化为一个值（可选）。 无论在何处声明变量，都会在执行任何代码之前进行处理。这被称为变量提升，我们将在下面进一步讨论。 用 var 声明的变量的作用域是它当前的执行上下文及其闭包（嵌套函数），或者对于声明在任何函数外的变量来说是全局。使用 var 重复声明 JavaScript 变量并不会抛出错误（即使在严格模式 (strict mode) 下），同时，变量也不会丢失其值，直到调用其它的赋值操作。 letlet 允许你声明一个作用域被限制在块作用域中的变量、语句或者表达式。与 var 关键字不同的是，var 声明的变量作用域是全局或者整个函数块的。 var 和 let 的另一个重要区别，let 声明的变量不会在作用域中被提升，它是在编译时才初始化（参考下面 暂时性死区）。 就像 const 一样，let 不会在全局声明时（在最顶部的范围）创建 window 对象的属性。 暂时性死区let 变量在声明之前，不能够读写。如果声明中未指定初始值，则变量将使用 undefined 值初始化，在声明之前访问变量会导致 ReferenceError。 备注： 与 var 变量不同，如果在声明前使用 var，变量将会被初始化为undefined。 从块作用域的顶部一直到变量声明完成之前，这个变量处在暂时性死区（TDZ，temporal dead zone）。 const此声明创建一个常量，其作用域可以是全局或本地声明的块。 与var变量不同，全局常量不会变为 window 对象的属性。需要一个常数的初始化器；也就是说，您必须在声明的同一语句中指定它的值（这是有道理的，因为以后不能更改）。 **const**声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。 关于“暂存死区”的所有讨论都适用于let和const。 一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。 如果希望const定义的对象的属性也不能被修改该怎么做？使用Object.freeze(obj)冻结obj，就能使其内部的属性不可变，但有局限，就是obj对象中要是有属性是对象，该对象内属性还能改变，要全不可变的话，就需要使用递归等方式一层一层全部冻结。 闭包 1、闭包是在函数创建时创建的，即有函数创建就会生成闭包； 2、闭包和其函数在同一上下文中； 3、闭包包含该作用域下的所有变量/引用地址； 4、定义函数不会创建闭包，只有创建/执行函数同时才创建闭包； BFC概念 BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述布局模式的流动模型。是W3C CSS2.1规范中的一个概念，决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。具有BFC特性的元素可以看做是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的的一些特性。通俗一点来讲，可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 形成BFC的条件只要元素满足下面任一条件即可触发BFC特性：body 根元素浮动元素：float 除 none 以外的值绝对定位元素：position (absolute、fixed)display 为 inline-block、table-cells、flexoverflow 除了 visible 以外的值 (hidden、auto、scroll) BFC常见作用 阻止外边距折叠 解决float浮动导致的高度塌陷，元素被浮动元素覆盖 事件冒泡和事件捕获1&lt;div id=&quot;outer&quot;&gt;&lt;p id=&quot;inner&quot;&gt;Click me!&lt;/p&gt; &lt;/div&gt; 事件冒泡微软提出了名为事件冒泡(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。 因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是 p -&gt; div -&gt; body -&gt; html -&gt; document 事件捕获网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。 上面的例子在事件捕获的概念下发生click事件的顺序应该是 document -&gt; html -&gt; body -&gt; div -&gt; p 事件冒泡和事件捕获过程图： 1-5是捕获过程，5-6是目标阶段，6-10是冒泡阶段； addEventListener 的第三个参数DOM2级事件”中规定的事件流同时支持了事件捕获阶段和事件冒泡阶段，而作为开发者，我们可以选择事件处理函数在哪一个阶段被调用。 addEventListener方法用来为一个特定的元素绑定一个事件处理函数，是JavaScript中的常用方法。addEventListener有三个参数： 1element.addEventListener(event, function, useCapture) 参数 描述 event 必须。字符串，指定事件名。 注意: 不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。 提示： 所有 HTML DOM 事件，可以查看我们完整的 HTML DOM Event 对象参考手册。 function 必须。指定要事件触发时执行的函数。 当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。例如， “click” 事件属于 MouseEvent(鼠标事件) 对象。 useCapture 可选。布尔值，指定事件是否在捕获或冒泡阶段执行。 可能值:true - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）false- false- 默认。事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数） 浏览器输入URL后发生了什么参考地址 谈谈 HTTPShttps://juejin.cn/post/6844903504046211079 谈谈前端的安全知识？XSS、CSRF，以及如何防范。寒冬求职之你必须要懂的Web安全 问：new 一个构造函数，如果函数返回 return {} 、 return null ， return 1 ， return true 会发生什么情况？如果函数返回一个对象，那么new 这个函数调用返回这个函数的返回对象，否则返回 new 创建的新对象 什么是作用域？ES5 中只存在两种作用域：全局作用域和函数作用域。在 JavaScript 中，我们将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套子作用域中根据标识符名称进行变量（变量名或者函数名）查找 什么是作用域链？首先要了解作用域链，当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止,，而作用域链，就是有当前作用域与上层作用域的一系列变量对象组成，它保证了当前执行的作用域对符合访问权限的变量和函数的有序访问。 JS 隐式转换，显示转换一般非基础类型进行转换时会先调用 valueOf，如果 valueOf 无法返回基本类型值，就会调用 toString JS 数据类型 基本类型：Number、Boolean、String、null、undefined、symbol（ES6 新增的），BigInt（ES2020） 引用类型：Object，对象子类型（Array，Function） Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办Math.pow(2, 53) ，53 为有效数字，会发生截断，等于 JS 能支持的最大数字。 原型与原型链什么是原型链？ 当对象查找一个属性的时候，如果没有在自身找到，那么就会查找自身的原型，如果原型还没有找到，那么会继续查找原型的原型，直到找到 Object.prototype 的原型时，此时原型为 null，查找停止。 这种通过 通过原型链接的逐级向上的查找链被称为原型链 什么是原型继承？ 一个对象可以使用另外一个对象的属性或者方法，就称之为继承。具体是通过将这个对象的原型设置为另外一个对象，这样根据原型链的规则，如果查找一个对象属性且在自身不存在时，就会查找另外一个对象，相当于一个对象可以使用另外一个对象的属性和方法了。 如果一个构造函数，bind了一个对象，用这个构造函数创建出的实例会继承这个对象的属性吗？为什么？不会继承，因为根据 this 绑定四大规则，new 绑定的优先级高于 bind 显示绑定，通过 new 进行构造函数调用时，会创建一个新对象，这个新对象会代替 bind 的对象绑定，作为此函数的 this，并且在此函数没有返回对象的情况下，返回这个新建的对象 浏览器跨域以及解决方法https://juejin.cn/post/7094162429310926855 览器有一个重要的安全策略，称之为「同源策略」 其中，源=协议+主机+端口源，两个源相同，称之为同源，两个源不同，称之为跨源或跨域 有多种方式解决跨域问题，常见的有： 代理，常用 CORS，常用 JSONP 无论使用哪一种方式，都是要让浏览器知道，我这次跨域请求的是自己人，就不要拦截了。 跨域解决方法1-代理对于前端开发而言，大部分的跨域问题，都是通过代理解决的 代理适用的场景是：生产环境不发生跨域，但开发环境发生跨域 因此，只需要在开发环境使用代理解决跨域即可，这种代理又称之为开发代理 123456789101112// vue 的开发服务器代理配置(webpack同理)// vue.config.jsmodule.exports = { devServer: { // 配置开发服务器 proxy: { // 配置代理 &quot;/api&quot;: { // 若请求路径以 /api 开头 target: &quot;http://dev.taobao.com&quot;, // 将其转发到 http://dev.taobao.com }, }, },}; 跨域解决方法2-JSONP在CORS出现之前，人们想了一种奇妙的办法来实现跨域，这就是JSONP。 要实现JSONP，需要浏览器和服务器来一个天衣无缝的绝妙配合。 JSONP的做法是：当需要跨域请求时，不使用AJAX，转而生成一个script元素去请求服务器，由于浏览器并不阻止script元素的请求，这样请求可以到达服务器。服务器拿到请求后，响应一段JS代码，这段代码实际上是一个函数调用，调用的是客户端预先生成好的函数，并把浏览器需要的数据作为参数传递到函数中，从而间接的把数据传递给客户端 跨域解决方法3-CORSCORS是基于http1.1的一种跨域解决方案，它的全称是Cross-Origin Resource Sharing，跨域资源共享。 它的总体思路是：如果浏览器要跨域访问服务器的资源，需要获得服务器的允许 !()","link":"/note/2022/07/10/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/"},{"title":"箭头函数","text":"箭头函数与普通函数有什么区别 箭头函数在写法上比普通函数更简洁。 箭头函数在声明时，如果没有参数可以直接写空括号 1const func = () =&gt; {} 只有一个参数时，括号可以省略；多个参数需要在空号内用逗号隔开: 12const func = x =&gt; {}const func = (x, y) =&gt; {} 当箭头函数体中只有返回值一句，可以省略大括号: 1const func = (x) =&gt; x + 10; 如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字： 1let func = (callBack) =&gt; void callBack(); 箭头函数的this、prototype箭头函数不存在自己的this，也没有prototype，箭头函数只会在自己当前定义的位置继承上一层this及父级作用域中的this，所以箭头函数中this在它被定义时就已经确定，不会改变，call、apply、bind也不能改变箭头函数的this；而普通函数的this在调用时才会确认，一般谁调用的它，它的this就指向谁，直接调用指向window/global（严格模式下为undefined） 123456789101112var g = 'abc';var obj = { g: 'objVal', funcA(){ console.log(this.g); }, funcB: () =&gt; { console.log(this.g); }};obj.funcA(); // 'objVal'obj.funcB(); // 'abc' 箭头函数不能作为构造函数使用new 一个构造函数时在会将该对象的__proto__指向到构造函数的原型prototype，还会将函数的this指向新创建的对象，由于箭头函数没有自己的this和prototype，所以不能作为构造函数使用。 箭头函数不能绑定arguments1234const func = (x) =&gt; { console.log(arguments); // Uncaught ReferenceError: arguments is not defined};func(); 但可以使用es6中的解构来获取所有参数： 1234const func = (...args) =&gt; { console.log(args);};func(); 箭头函数不可以使用yield，因此箭头函数不能当作Generator函数使用。","link":"/note/2022/03/28/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/note/tags/JavaScript/"},{"name":"Vue","slug":"Vue","link":"/note/tags/Vue/"},{"name":"ajax","slug":"ajax","link":"/note/tags/ajax/"},{"name":"node","slug":"node","link":"/note/tags/node/"},{"name":"npm","slug":"npm","link":"/note/tags/npm/"},{"name":"TypeSctipt","slug":"TypeSctipt","link":"/note/tags/TypeSctipt/"},{"name":"vue-router","slug":"vue-router","link":"/note/tags/vue-router/"},{"name":"vuex","slug":"vuex","link":"/note/tags/vuex/"},{"name":"JavaSciprt","slug":"JavaSciprt","link":"/note/tags/JavaSciprt/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/note/categories/JavaScript/"},{"name":"Vue","slug":"Vue","link":"/note/categories/Vue/"},{"name":"ajax","slug":"JavaScript/ajax","link":"/note/categories/JavaScript/ajax/"},{"name":"JavaScript","slug":"Vue/JavaScript","link":"/note/categories/Vue/JavaScript/"},{"name":"node","slug":"node","link":"/note/categories/node/"},{"name":"TypeSctipt","slug":"TypeSctipt","link":"/note/categories/TypeSctipt/"},{"name":"vue-router","slug":"vue-router","link":"/note/categories/vue-router/"},{"name":"vuex","slug":"vuex","link":"/note/categories/vuex/"},{"name":"JavaSciprt","slug":"JavaSciprt","link":"/note/categories/JavaSciprt/"},{"name":"npm","slug":"node/npm","link":"/note/categories/node/npm/"}],"pages":[{"title":"about","text":"","link":"/note/about/index.html"}]}